/**********************************************************************
 * Copyright by Jonas Thies, Univ. of Groningen 2006/7/8.             *
 * Permission to use, copy, modify, redistribute is granted           *
 * as long as this header remains intact.                             *
 * contact: jonas@math.rug.nl                                         *
 *                                                                    *
 **********************************************************************/
/* -Messed up by Erik                                                 *
 **********************************************************************/

// for I-EMIC couplings
#include <math.h>
#include <iostream>
#include <sstream>
#include <memory>
#include <vector>
#include <algorithm>

#include "Teuchos_StandardCatchMacros.hpp"

#include "Epetra_Comm.h"
#include "Epetra_Map.h"
#include "Epetra_CrsGraph.h"
#include "Epetra_Vector.h"
#include "Epetra_IntVector.h"
#include "Epetra_Import.h"
#include "Epetra_CrsMatrix.h"
#include "Epetra_Time.h"

#include "EpetraExt_MultiComm.h"
#include "EpetraExt_BlockVector.h"

// define global macros such as UU, _NUN_, INFO etc.
#include "THCMdefs.H"

// from TRIOS
#include "TRIOS_Domain.H"

// from trilinos_thcm
#include "THCM.H"

#ifdef DEBUGGING
#include "OceanGrid.H"
#endif

//============================================================================
extern "C" {

    // usrc.F90
    _SUBROUTINE_(setparcs)(int*,double*);
    _SUBROUTINE_(getparcs)(int*,double*);
    _SUBROUTINE_(writeparams)();
    _SUBROUTINE_(rhs)(double*,double*);
    _SUBROUTINE_(setsres)(int *);
    _SUBROUTINE_(matrix)(double*);
    _SUBROUTINE_(stochastic_forcing)();

    // input:   n,m,l,nmlglob
    //          xmin,xmax,ymin,ymax,
    //          periodic,landm,
    //          taux,tauy,tatm,emip,spert
    _SUBROUTINE_(init)(int*,int*,int*,int*,
                       double*,double*,double*,double*,
                       int*,int*,
                       double*,double*,double*,double*,double*);

    // input:   landm
    _SUBROUTINE_(set_landmask)(int *, int *, int *);

    _SUBROUTINE_(finalize)(void);

    // global.F90
    // input:   N,M,L,
    //          Xmin,Xmax,Ymin,Ymax,hdim,qz,
    //          alphaT,alphaS,
    //          ih,vmix_GLB,tap,rho_mixing,
    //          periodic,itopo,flat,rd_mask,
    //          TRES,SRES,iza,ite,its,rd_spertm
    //          coupled_T, coupled_S, coriolis_on,
    //          forcing_type
    _MODULE_SUBROUTINE_(m_global,initialize)(int*,int*,int*,
                                             double*,double*,double*,double*,double*,double*,
                                             double*,double*,
                                             int*,int*,int*,int*,
                                             int*,int*,int*,int*,
                                             int*,int*,int*,int*,int*,int*,
                                             int*,int*,int*,
                                             int*);

    _MODULE_SUBROUTINE_(m_global,finalize)(void);
    _MODULE_SUBROUTINE_(m_global,get_landm)(int*);
    _MODULE_SUBROUTINE_(m_global,get_current_landm)(int*);
    _MODULE_SUBROUTINE_(m_global,set_landm)(int*);
    _MODULE_SUBROUTINE_(m_global,get_monthly_forcing)(double* tatm, double* emip,
                                                      double* taux, double* tauy, int* month);
    _MODULE_SUBROUTINE_(m_global,get_monthly_internal_forcing)(double* temp, double* salt,
                                                               int* month);
    _MODULE_SUBROUTINE_(m_global,get_windfield)(double* taux, double* tauy);
    _MODULE_SUBROUTINE_(m_global,get_temforcing)(double* tatm);
    _MODULE_SUBROUTINE_(m_global,get_salforcing)(double* emip);
    _MODULE_SUBROUTINE_(m_global,get_internal_temforcing)(double* temp);
    _MODULE_SUBROUTINE_(m_global,get_internal_salforcing)(double* salt);
    _MODULE_SUBROUTINE_(m_global,get_spert)(double* spert);

    _MODULE_SUBROUTINE_(m_monthly,set_forcing)(double*tatm, double* emip, double* taux,
                                               double* tauy, int* month);
    _MODULE_SUBROUTINE_(m_monthly,set_internal_forcing)(double*temp, double* salt, int* month);
    _MODULE_SUBROUTINE_(m_usr,set_internal_forcing)(double*temp, double* salt);
    _MODULE_SUBROUTINE_(m_thcm_utils,get_landm)(int*);
    _MODULE_SUBROUTINE_(m_scaling,average_block)(double *db);
    _MODULE_SUBROUTINE_(m_scaling,compute)(double *db, double *rowscales, double* colscales);

    _SUBROUTINE_(fillcolb)(void);

    // CRS matrix allocation (module m_mat)
    _MODULE_SUBROUTINE_(m_mat,get_array_sizes)(int* nrows, int* nnz);
    _MODULE_SUBROUTINE_(m_mat,set_pointers)(int* nrows, int* nnz,
                                            int* begA,int* jcoA,double* coA,
                                            double* coB,
                                            int* begF,int* jcoF,double* coF);

    // compute scaling factors for S-integral condition. Values is an n*m*l array
    _MODULE_SUBROUTINE_(m_thcm_utils,intcond_scaling)(double* values,int* indices,int* len);

    // compute weights for load balancing
    _MODULE_SUBROUTINE_(m_thcm_utils,loadbal_weights)(double* weights,double*,double*,double*);

    // sets the vmix_fix flag
    _MODULE_SUBROUTINE_(m_mix,set_vmix_fix)(int* vmix_fix);

    // for time-dependent forcing (gamma* is a continuation parameter for wind, T and S):
    _MODULE_SUBROUTINE_(m_monthly,update_forcing)(double* t,
                                                  double* gammaw,double* gammat, double* gammas);
    _MODULE_SUBROUTINE_(m_monthly,update_internal_forcing)(double* t,
                                                           double* gammat, double* gammas);

    //---------------------- I-EMIC couplings--------------------------------------
    // Extensions created for communication within the I-EMIC
    //
    _MODULE_SUBROUTINE_(m_inserts, insert_atmosphere_t)(double *atmosT);
    _MODULE_SUBROUTINE_(m_inserts, insert_atmosphere_q)(double *atmosQ);
    _MODULE_SUBROUTINE_(m_inserts, insert_atmosphere_a)(double *atmosQ);
    _MODULE_SUBROUTINE_(m_inserts, insert_atmosphere_p)(double *atmosP);
    _MODULE_SUBROUTINE_(m_inserts, insert_seaice_q)(double *seaiceT);
    _MODULE_SUBROUTINE_(m_inserts, insert_seaice_m)(double *seaiceM);
    _MODULE_SUBROUTINE_(m_inserts, insert_seaice_g)(double *seaiceM);
    _MODULE_SUBROUTINE_(m_inserts, insert_emip)(double *emip);
    _MODULE_SUBROUTINE_(m_inserts, insert_adapted_emip)(double *emip);
    _MODULE_SUBROUTINE_(m_inserts, insert_emip_pert)(double *emip);
    _MODULE_SUBROUTINE_(m_inserts, insert_tatm)(double *emip);

    _MODULE_SUBROUTINE_(m_integrals, salt_advection)(double *un, double *check);
    _MODULE_SUBROUTINE_(m_integrals, salt_diffusion)(double *un, double *check);

    _MODULE_SUBROUTINE_(m_probe,  get_emip)(double *emip);
    _MODULE_SUBROUTINE_(m_probe,  get_suno)(double *suno);
    _MODULE_SUBROUTINE_(m_probe,  get_derivatives)(double *sol, double *dftdm,
                                                   double *dfsdq, double *dfsdm,
                                                   double *dfsdg);
    _MODULE_SUBROUTINE_(m_probe,  get_adapted_emip)(double *emip);
    _MODULE_SUBROUTINE_(m_probe,  get_emip_pert)(double *emip);
    _MODULE_SUBROUTINE_(m_probe,  get_salflux)(double *sol, double *salflux,
                                               double *scorr,
                                               double *qsoaflux, double *qsosflux);

    _MODULE_SUBROUTINE_(m_probe,  get_temflux)(double *sol, double *totflux,
                                               double *swflux, double *shflux,
                                               double *lhflux, double *siflux,
                                               double *simask);

    _MODULE_SUBROUTINE_(m_probe,  get_atmosphere_t)(double *atmosT);
    _MODULE_SUBROUTINE_(m_probe,  get_atmosphere_q)(double *atmosQ);
    _MODULE_SUBROUTINE_(m_probe,  get_atmosphere_p)(double *atmosP);
    _MODULE_SUBROUTINE_(m_probe,  compute_evap)(double *oceanE, double *x);

    _MODULE_SUBROUTINE_(m_global, get_land_temp)(double *land);
    //-----------------------------------------------------------------------------

    _SUBROUTINE_(write_levitus)(const char*);

}//extern

//=============================================================================
// constructor
THCM::THCM(Teuchos::RCP<Teuchos::ParameterList> params, Teuchos::RCP<Epetra_Comm> comm)
    : THCM(*params, comm)
{}

//=============================================================================
// constructor
THCM::THCM(Teuchos::ParameterList& params, Teuchos::RCP<Epetra_Comm> comm) :
    Singleton<THCM>(Teuchos::rcp(this, false)),
    Comm(comm),
    nullSpace(Teuchos::null),
    paramList(Teuchos::rcp(new Teuchos::ParameterList))
{
    DEBUG("### enter THCM::THCM ###");

    *paramList=params;

    paramList->validateParametersAndSetDefaults(getDefaultInitParameters());
    setPreParameters();

    std::string probdesc = paramList->get<std::string>("Problem Description");

    std::stringstream ss;
    ss << "THCM (" << probdesc <<", "
       << n << "x" << m << "x" << l <<")";
    INFO(ss.str());
    this->SetLabel(ss.str().c_str());

    // sanity check
    double xdist = pow(cos(xmax)-cos(xmin), 2) + pow(sin(xmax)-sin(xmin), 2);
    if ((xdist < 1e-2) && (periodic == false))
    {
        WARNING("Periodic bdc disabled while \n"
                << " horizontal boundaries coincide. Distance: "
                << xdist, __FILE__, __LINE__);
    }

    double qz      = paramList->get<double>("Grid Stretching qz");
    int    itopo   = paramList->get<int>("Topography");
    bool   flat    = paramList->get<bool>("Flat Bottom");
    bool   rd_mask = paramList->get<bool>("Read Land Mask"); //== false in experiment0

    if (rd_mask)
    {
        // we put the name of the desired mask in a file so it can be
        // obtained from there by the fortran code:
        std::string mask_file = paramList->get<std::string>("Land Mask");
        if (Comm->MyPID() == 0)
        {
            std::ofstream mfs("mask_name.txt", std::ios::trunc);
            mfs << mask_file;
        }
    }

    int coriolis_on  = paramList->get<int>("Coriolis Force");
    int forcing_type = paramList->get<int>("Forcing Type");

    //------------------------------------------------------------------
    if ((coupled_S == 1) && (sres == 1))
    {
        WARNING("Incompatible parameters: coupled_S = " << coupled_S
                << " sres = "
                << sres << " setting sres = 0", __FILE__, __LINE__);
        sres = 0;
    }

    bool rd_spertm = paramList->get<bool>("Read Salinity Perturbation Mask");
    if (rd_spertm)
    {
        std::string spertm_file = paramList->get<std::string>("Salinity Perturbation Mask");
        if (Comm->MyPID()==0)
        {
            std::ofstream mfs("spertm_name.txt",std::ios::trunc);
            mfs << spertm_file;
        }
    }

    //------------------------------------------------------------------
    if (std::abs(intSign_) != 1)
    {
        ERROR("Invalid integral sign!", __FILE__, __LINE__);
    }

    if (Comm->MyPID() == 0)
    {
        std::ofstream windfile("windf_name.txt", std::ios::trunc);
        std::ofstream sstfile("sstf_name.txt",   std::ios::trunc);
        std::ofstream sssfile("sssf_name.txt",   std::ios::trunc);
        // Let THCM know the wind forcing file
        windfile << paramList->get<std::string>("Wind Forcing Data");
        // Let THCM know the sst forcing file
        sstfile  << paramList->get<std::string>("Temperature Forcing Data");
        // Let THCM know the sss forcing file
        sssfile  << paramList->get<std::string>("Salinity Forcing Data");
    }
    //-----------------------------------------------------------------


    int dof = _NUN_; // number of unknowns, defined in THCMdefs.H

    // construct an object to decompose the domain:
    domain = Teuchos::rcp(new TRIOS::Domain(n, m, l, dof, xmin, xmax, ymin, ymax,
                                            periodic, hdim, qz, Comm));

    // perform a 2D decomposition of domain into rectangular boxes
    domain->Decomp2D();

    // get a map object representing the subdomain (with ghost-nodes/overlap).
    // This map defines the nodes local to the THCM subdomain
    AssemblyMap = domain->GetAssemblyMap();

    // get a map object representing the subdomain (without ghost-nodes/overlap).
    // this is an intermediate representation between the assembly and the solve
    // phases.
    StandardMap = domain->GetStandardMap();

    // initialize THCM (allocate memory etc.)
    // for a subdomain including ghost-nodes:

    // the domain object knows the geometry of the subdomain:
    double xminloc = domain->XminLoc();
    double xmaxloc = domain->XmaxLoc();
    double yminloc = domain->YminLoc();
    double ymaxloc = domain->YmaxLoc();

    // and the number of grid points contained in it:
    int nloc = domain->LocalN();
    int mloc = domain->LocalM();
    int lloc = domain->LocalL();

    // global settings for THCM
    // memory for I/O is allocated only on the root process (pid 0)
    int nglob_ = 0;
    int mglob_ = 0;
    int lglob_ = 0;

    if (Comm->MyPID() == 0) // this one is responsible for I/O
    {
        nglob_ = n;
        mglob_ = m;
        lglob_ = l;
    }

    // fortran routine that puts global info in module m_global
    // and allocates some arrays there if dimensions are non-zero
    // this has to be called _before_ init because init already uses
    // some of it (by calling 'forcing')

    // for portability reasons we rather pass integers to fortran than bools
    // (this was an issue on Huygens)
    int irho_mixing = (rho_mixing) ? 1 : 0;
    int iperiodic   = (periodic  ) ? 1 : 0;
    int iflat       = (flat      ) ? 1 : 0;
    int ird_mask    = (rd_mask   ) ? 1 : 0;
    int ird_spertm  = (rd_spertm ) ? 1 : 0;

    INFO("THCM init: m_global::initialize...");
    INFO("    Mixing: vmix_GLB = " << vmix_GLB);

    // In fortran object code this corresponds to the function
    //  __m_global_MOD_initialize
    F90NAME(m_global, initialize)(&nglob_, &mglob_, &lglob_,
                                  &xmin, &xmax, &ymin, &ymax, &hdim, &qz,
                                  &alphaT, &alphaS,
                                  &ih, &vmix_GLB, &tap, &irho_mixing,
                                  &iperiodic, &itopo, &iflat, &ird_mask,
                                  &tres, &sres, &iza, &ite, &its, &ird_spertm,
                                  &coupled_T, &coupled_S, &coriolis_on,
                                  &forcing_type);

    INFO("THCM init: m_global::initialize... done");

    if (localSres_) // from here on we ignore the integral condition
        sres = 1;

    // read topography data and convert it to a global land mask
    DEBUG("Initialize land mask...");

    int I0 = 0; int I1 = n+1;
    int J0 = 0; int J1 = m+1;
    int K0 = 0; int K1 = l+1;

    int i0=0, i1=-1, j0=0, j1=-1,k0=0,k1=-1;
    // global (gathered) map, all inds are on root proc, the ranges are
    if (comm->MyPID()==0)
    {
        i1 = I1; j1 = J1; k1=K1;
    }

// the next part of this file is devoted to taking arrays from m_global that
// have been read from files and putting them into m_usr, where they will be
// distributed and have two layers of overlap. This is done for many different
// arrays in exactly the same way, so it would call for some abstraction layer,
// but we currently do it separately for all arrays (TODO: make this general).
//
// The arrays are:
//
// landm: land mask, integer 3D
// taux,tauy: wind field, double 2D
// tatm: atmosphere temperature, double 2D
// emip: surface salinity forcing, double 2D
// temp: internal temperature forcing, double 3D
// salt: internal salinity forcing, double 3D

    DEBUG("Create gathered land map");
    Teuchos::RCP<Epetra_Map> landmap_glb =
        Utils::CreateMap(i0,i1,j0,j1,k0,k1,I0,I1,J0,J1,K0,K1,*comm);

    // sequential landm array on proc 0
    Teuchos::RCP<Epetra_IntVector> landm_glb =
        Teuchos::rcp(new Epetra_IntVector(*landmap_glb));

    int *landm;
    if (comm->MyPID()==0)
    {
        CHECK_ZERO(landm_glb->ExtractView(&landm));
        // make THCM fill the global landm array and put it into our C pointer location
        DEBUG("call m_global::get_landm");
        F90NAME(m_global,get_landm)(landm);
    }

    Teuchos::RCP<Epetra_IntVector> landm_loc = distributeLandMask(landm_glb);

    // import local landm-part to THCM
    CHECK_ZERO(landm_loc->ExtractView(&landm));

    // in the main part of THCM (except m_global) we set periodic
    // boundary conditions to .false. _unless_ we are running a
    // periodic problem on a single CPU in the x-direction:
    Teuchos::RCP<Epetra_Comm> xComm = domain->GetProcRow(0);

    int perio = (periodic && xComm->NumProc() == 1);

    int nmlglob = n*m*l;

    //--------------------------------------------------------------------------
    // read wind, temperature and salinity forcing and distribute it among
    // processors
    Teuchos::RCP<Epetra_Map> wind_map_loc   = domain->CreateAssemblyMap(1,true);

    // Single-unknown surface maps
    StandardSurfaceMap = domain->CreateStandardMap(1,true);
    AssemblySurfaceMap = domain->CreateAssemblyMap(1,true);

    // Surface assembly/standard import strategy
    as2std_surf =
        Teuchos::rcp(new Epetra_Import(*AssemblySurfaceMap, *StandardSurfaceMap));

    // Single-unknown volume maps
    StandardVolumeMap = domain->CreateStandardMap(1,false);
    AssemblyVolumeMap = domain->CreateAssemblyMap(1,false);

    // Volume assembly/standard import strategy
    as2std_vol =
        Teuchos::rcp(new Epetra_Import(*AssemblyVolumeMap, *StandardVolumeMap));


    Teuchos::RCP<Epetra_Map> lev_map_loc    = wind_map_loc;
    Teuchos::RCP<Epetra_Map> intlev_map_loc = domain->CreateAssemblyMap(1,false);
    Teuchos::RCP<Epetra_Vector> taux_loc    = Teuchos::rcp(new Epetra_Vector(*wind_map_loc));
    Teuchos::RCP<Epetra_Vector> tauy_loc    = Teuchos::rcp(new Epetra_Vector(*wind_map_loc));
    Teuchos::RCP<Epetra_Vector> tatm_loc    = Teuchos::rcp(new Epetra_Vector(*lev_map_loc));
    Teuchos::RCP<Epetra_Vector> emip_loc    = Teuchos::rcp(new Epetra_Vector(*lev_map_loc));
    Teuchos::RCP<Epetra_Vector> temp_loc    = Teuchos::rcp(new Epetra_Vector(*intlev_map_loc));
    Teuchos::RCP<Epetra_Vector> salt_loc    = Teuchos::rcp(new Epetra_Vector(*intlev_map_loc));
    Teuchos::RCP<Epetra_Vector> spert_loc   = Teuchos::rcp(new Epetra_Vector(*lev_map_loc));

    double* taux;
    double* tauy;
    double* tatm;
    double* emip;
    double* temp;
    double* salt;
    double* spert;

    CHECK_ZERO(taux_loc->ExtractView(&taux));
    CHECK_ZERO(tauy_loc->ExtractView(&tauy));
    CHECK_ZERO(tatm_loc->ExtractView(&tatm));
    CHECK_ZERO(emip_loc->ExtractView(&emip));
    CHECK_ZERO(temp_loc->ExtractView(&temp));
    CHECK_ZERO(salt_loc->ExtractView(&salt));
    CHECK_ZERO(spert_loc->ExtractView(&spert));

    DEBUG("Initialize Wind field...");

    Teuchos::RCP<Epetra_Map> wind_map_dist = domain->CreateStandardMap(1,true);
    Teuchos::RCP<Epetra_Map> wind_map_root = Utils::Gather(*wind_map_dist,0);

    Teuchos::RCP<Epetra_Vector> taux_glob =
        Teuchos::rcp(new Epetra_Vector(*wind_map_root));
    Teuchos::RCP<Epetra_Vector> tauy_glob =
        Teuchos::rcp(new Epetra_Vector(*wind_map_root));

    double *taux_g, *tauy_g;
    CHECK_ZERO(taux_glob->ExtractView(&taux_g));
    CHECK_ZERO(tauy_glob->ExtractView(&tauy_g));

    if (comm->MyPID()==0)
    {
        std::cout << " obtaining windfield" << std::endl;
        F90NAME(m_global,get_windfield)(taux_g,tauy_g);
    }

    // distribute wind fields
    Teuchos::RCP<Epetra_MultiVector> taux_dist =
        Utils::Scatter(*taux_glob,*wind_map_dist);
    Teuchos::RCP<Epetra_MultiVector> tauy_dist =
        Utils::Scatter(*tauy_glob,*wind_map_dist);

    // import overlap
    Teuchos::RCP<Epetra_Import> wind_loc2dist =
        Teuchos::rcp(new Epetra_Import(*wind_map_loc,*wind_map_dist));
    CHECK_ZERO(taux_loc->Import(*taux_dist,*wind_loc2dist,Insert));
    CHECK_ZERO(tauy_loc->Import(*tauy_dist,*wind_loc2dist,Insert));

    double tauxmax, tauymax;
    double tauxmin, tauymin;
    CHECK_ZERO(taux_dist->MaxValue(&tauxmax));
    CHECK_ZERO(tauy_dist->MaxValue(&tauymax));
    CHECK_ZERO(taux_dist->MinValue(&tauxmin));
    CHECK_ZERO(tauy_dist->MinValue(&tauymin));

    INFO("Zonal wind forcing from data ranges between: ["
         << tauxmin << ".." << tauxmax << "]");
    INFO("Meridional wind forcing from data ranges between: ["
         << tauymin << ".." << tauymax << "]");

    DEBUG("Initialize Temperature and Salinity forcing...");

    Teuchos::RCP<Epetra_Map> lev_map_dist  = domain->CreateStandardMap(1,true);

    Teuchos::RCP<Epetra_Map> lev_map_root  = Utils::Gather(*lev_map_dist,0);

    Teuchos::RCP<Epetra_Map> intlev_map_dist  = domain->CreateStandardMap(1,false);
    Teuchos::RCP<Epetra_Map> intlev_map_root  = Utils::Gather(*intlev_map_dist,0);

    Teuchos::RCP<Epetra_Vector> tatm_glob     =
        Teuchos::rcp(new Epetra_Vector(*lev_map_root));
    Teuchos::RCP<Epetra_Vector> emip_glob     =
        Teuchos::rcp(new Epetra_Vector(*lev_map_root));
    Teuchos::RCP<Epetra_Vector> temp_glob     =
        Teuchos::rcp(new Epetra_Vector(*intlev_map_root));
    Teuchos::RCP<Epetra_Vector> salt_glob     =
        Teuchos::rcp(new Epetra_Vector(*intlev_map_root));
    Teuchos::RCP<Epetra_Vector> spert_glob    =
        Teuchos::rcp(new Epetra_Vector(*lev_map_root));

    double *tatm_g, *emip_g, *spert_g, *temp_g, *salt_g;
    CHECK_ZERO(tatm_glob->ExtractView(&tatm_g));
    CHECK_ZERO(emip_glob->ExtractView(&emip_g));
    CHECK_ZERO(temp_glob->ExtractView(&temp_g));
    CHECK_ZERO(salt_glob->ExtractView(&salt_g));
    CHECK_ZERO(spert_glob->ExtractView(&spert_g));

    if (comm->MyPID() == 0)
    {
        F90NAME(m_global, get_temforcing)(tatm_g);
        F90NAME(m_global, get_salforcing)(emip_g);
        if (internal_forcing)
        {
            F90NAME(m_global,get_internal_temforcing)(temp_g);
            F90NAME(m_global,get_internal_salforcing)(salt_g);
        }
        else
        {
            temp_glob->PutScalar(0.0);
            salt_glob->PutScalar(0.0);
        }
        F90NAME(m_global,get_spert)(spert_g);
    }

    // distribute levitus fields
    Teuchos::RCP<Epetra_MultiVector> tatm_dist     =
        Utils::Scatter(*tatm_glob, *lev_map_dist);
    Teuchos::RCP<Epetra_MultiVector> emip_dist     =
        Utils::Scatter(*emip_glob, *lev_map_dist);
    Teuchos::RCP<Epetra_MultiVector> temp_dist     =
        Utils::Scatter(*temp_glob, *intlev_map_dist);
    Teuchos::RCP<Epetra_MultiVector> salt_dist     =
        Utils::Scatter(*salt_glob, *intlev_map_dist);
    Teuchos::RCP<Epetra_MultiVector> spert_dist    =
        Utils::Scatter(*spert_glob, *lev_map_dist);

    // import overlap
    Teuchos::RCP<Epetra_Import> lev_loc2dist =
        Teuchos::rcp(new Epetra_Import(*lev_map_loc, *lev_map_dist));
    Teuchos::RCP<Epetra_Import> intlev_loc2dist =
        Teuchos::rcp(new Epetra_Import(*intlev_map_loc, *intlev_map_dist));

    CHECK_ZERO(tatm_loc->Import(*tatm_dist, *lev_loc2dist, Insert));
    CHECK_ZERO(emip_loc->Import(*emip_dist, *lev_loc2dist, Insert));
    CHECK_ZERO(temp_loc->Import(*temp_dist, *intlev_loc2dist, Insert));
    CHECK_ZERO(salt_loc->Import(*salt_dist, *intlev_loc2dist, Insert));
    CHECK_ZERO(spert_loc->Import(*spert_dist, *lev_loc2dist, Insert));
    double tatmmax, emipmax;
    double tatmmin, emipmin;
    CHECK_ZERO(tatm_dist->MaxValue(&tatmmax));
    CHECK_ZERO(emip_dist->MaxValue(&emipmax));
    CHECK_ZERO(tatm_dist->MinValue(&tatmmin));
    CHECK_ZERO(emip_dist->MinValue(&emipmin));

    INFO("Temperature forcing from data ranges between: ["
         << tatmmin <<".." << tatmmax << "]");
    INFO("Salinity forcing from data ranges between: ["
         << emipmin <<".." <<emipmax <<"]");

////////////////////////////////////////////////////////////////////////////////

    // initialize THCM subdomain
    DEBUG("call init..."); // in usrc.F90
    FNAME(init)(&nloc, &mloc, &lloc, &nmlglob,
                &xminloc, &xmaxloc, &yminloc, &ymaxloc,
                &perio, landm,
                taux, tauy, tatm, emip, spert);

    INFO("   initialize THCM subdomain done");

    if (internal_forcing)
    {
        F90NAME(m_usr,set_internal_forcing)(temp,salt);
    }

    bool time_dep_forcing = paramList->get<bool>("Time Dependent Forcing");
    if (time_dep_forcing)
    {
        // read and distribute Levitus data
        this->SetupMonthlyForcing();
    }

    // get a map object for constructing vectors without overlap
    // (load-balanced, used for solve phase)
    SolveMap = domain->GetSolveMap();

    // Create internal vectors
    initialSolution = Teuchos::rcp(new Epetra_Vector(*SolveMap));
    diagB           = Teuchos::rcp(new Epetra_Vector(*SolveMap));
    localDiagB      = Teuchos::rcp(new Epetra_Vector(*StandardMap));
    localRhs        = Teuchos::rcp(new Epetra_Vector(*AssemblyMap));
    localSol        = Teuchos::rcp(new Epetra_Vector(*AssemblyMap));

    // 2D overlapping interface fields
    localAtmosT     = Teuchos::rcp(new Epetra_Vector(*AssemblySurfaceMap));
    localAtmosQ     = Teuchos::rcp(new Epetra_Vector(*AssemblySurfaceMap));
    localAtmosA     = Teuchos::rcp(new Epetra_Vector(*AssemblySurfaceMap));
    localAtmosP     = Teuchos::rcp(new Epetra_Vector(*AssemblySurfaceMap));
    localSeaiceQ    = Teuchos::rcp(new Epetra_Vector(*AssemblySurfaceMap));
    localSeaiceM    = Teuchos::rcp(new Epetra_Vector(*AssemblySurfaceMap));
    localSeaiceG    = Teuchos::rcp(new Epetra_Vector(*AssemblySurfaceMap));
    localOceanE     = Teuchos::rcp(new Epetra_Vector(*AssemblySurfaceMap));
    localEmip       = Teuchos::rcp(new Epetra_Vector(*AssemblySurfaceMap));
    localSurfTmp    = Teuchos::rcp(new Epetra_Vector(*AssemblySurfaceMap));
    localTatm       = Teuchos::rcp(new Epetra_Vector(*AssemblySurfaceMap));

    // allocate mem for the CSR matrix in THCM.
    // first ask how big it should be:
    int nrows, nnz;
    DEBUG("call get_array_sizes...");
    F90NAME(m_mat,get_array_sizes)(&nrows,&nnz);
    INFO("Allocating Fortran CSR arrays, nrows=" << nrows << ", nnz=" << nnz);

    // allocate the memory
    begA = new int[nrows+1];
    coA  = new double[nnz];
    jcoA = new int[nnz];

    coB  = new double[nrows];

    begF = new int[nrows+1];
    coF  = new double[nrows];
    jcoF = new int[nrows];

    // give THCM the opportunity to set its pointers to
    // the new memory block
    DEBVAR("call set_pointers...");
    F90NAME(m_mat,set_pointers)(&nrows,&nnz,begA,jcoA,coA,coB,begF,jcoF,coF);

    // Initialize integral condition row, correction and coefficients
    rowintcon_     = -1;
    intCorrection_ = 0.0;

    // Initialize salinity flux correction
    scorr_ = 0.0;

    // Obtain integral condition coefficients

    int N = domain->GlobalN();
    int M = domain->GlobalM();
    int L = domain->GlobalL();

    int Nic = paramList->get<int>("Integral row coordinate i");
    if (Nic == -1) {
        Nic = N-1;
    }
    int Mic = paramList->get<int>("Integral row coordinate j");
    if (Mic == -1) {
        Mic = M-1;
    }
    int midx;     // mask index
    int mval = 1; // mask value
    int tmp  = 0;
    if (sres == 0)
    {
        if (comm->MyPID() == 0)
        {
            midx = FIND_ROW2(1, N+2, M+2, L+2, Nic + 1, Mic + 1, L, 1);
            tmp = (*landm_glb)[midx];
        }
        comm->SumAll(&tmp, &mval, 1);

        if (mval != 0) // throw ERROR if integral row on land
        {
            if (comm->MyPID() == 0)
            {
                for (int j = M+1; j >= 0; --j)
                {
                    for (int i = 0; i != N+2; ++i)
                    {
                        midx = FIND_ROW2(1, N+2, M+2, L+2, i, j, L, 1);
                        std::cout << (*landm_glb)[midx];
                    }
                    std::cout << std::endl;
                }
            }

            ERROR("Integral row coordinates ("
                  << Nic << "," << Mic << ") give a land point! \n"
                  << "  Please give better coordinates in xml.",
                  __FILE__, __LINE__);
        }

        // location of integral condition
        rowintcon_ = FIND_ROW2(_NUN_,N,M,L,Nic,Mic,L-1,SS);

        INFO("THCM: integral condition for S is in global row " << rowintcon_);

    }

    // Initialize integral coefficients
    intcond_coeff = Teuchos::rcp(new Epetra_Vector(*SolveMap));

    // Obtain integral coefficients
    getIntCondCoeff();

    // create a graph describing the maximal matrix pattern.
    // Note that in LOCA we can't change the pattern of the matrix
    // during the continuation process as we pass pointers to LOCA
    // which can't be changed, whereas changing the pattern would
    // require building a whole new matrix. As we can't predict
    // where convective adjustment will happen, we assume it hap-
    // pens everywhere.
    localMatrixGraph = this->CreateMaximalGraph();
    testMatrixGraph  = this->CreateMaximalGraph(false);

    if (SolveMap!=StandardMap)
    {
        MatrixGraph = Teuchos::rcp(new Epetra_CrsGraph(Copy,*SolveMap,20));
        Teuchos::RCP<Epetra_Import> import = Teuchos::rcp(new Epetra_Import(*StandardMap,*SolveMap));
        DEBUG("Migrate graph to solve map...");
        CHECK_ZERO(MatrixGraph->Export(*localMatrixGraph,*import,Insert));
        CHECK_ZERO(MatrixGraph->FillComplete());
    }
    else
    {
        MatrixGraph = localMatrixGraph;
    }
    localJac = Teuchos::rcp(new Epetra_CrsMatrix(Copy, *localMatrixGraph));
    localJac->SetLabel("Local Jacobian");

    testJac = Teuchos::rcp(new Epetra_CrsMatrix(Copy, *testMatrixGraph));
    testJac->SetLabel("Testing Jacobian");

    Jac = Teuchos::rcp(new Epetra_CrsMatrix(Copy, *MatrixGraph));
    Jac->SetLabel("Jacobian");

    localFrc = Teuchos::rcp(new Epetra_CrsMatrix(Copy, *StandardMap, 1));
    localFrc->SetLabel("Local Forcing");
    Frc = Teuchos::rcp(new Epetra_CrsMatrix(Copy, *SolveMap, 1));
    Frc->SetLabel("Forcing");

    // we do not allow these to be modified, use the OceanModel interface
    // (computeShiftedMatrix, setXdot)
    // for implementing Time integration or eigenvalue things.
    sigmaUVTS=0.0;
//  sigmaWP=1.0e-14;
    sigmaWP=0.0;

// we can select two points where the continuity equation will be replaced by
// P(i,j,k) = 0. This is experimental, we hope to fix the divergence problem in the 4D case
//  like this
//      int N = domain->GlobalN();
//      int M = domain->GlobalM();
//      int L = domain->GlobalL();
//

    if (fixPressurePoints_)
    {
        rowPfix1 = FIND_ROW2(_NUN_,N,M,L,N-1,M-1,L-1,PP);
        rowPfix2 = FIND_ROW2(_NUN_,N,M,L,N-2,M-1,L-1,PP);
    }
    else
    {
        rowPfix1 = -1;
        rowPfix2 = -1;
    }

    // build vector with integral coefficients
    this->evaluateB();

    scaling_type=paramList->get<std::string>("Scaling");

    if (scaling_type=="THCM")
    {
        // construct the scaling object. The scaling is computed by THCM (m_scaling)
        // and passed on to Trilinos:
        row_scaling = Teuchos::rcp(new Epetra_Vector(*SolveMap));
        row_scaling->SetLabel("Row Scaling");
        col_scaling = Teuchos::rcp(new Epetra_Vector(*SolveMap));
        col_scaling->SetLabel("Col Scaling");
        local_row_scaling = Teuchos::rcp(new Epetra_Vector(*AssemblyMap) );
        local_col_scaling = Teuchos::rcp(new Epetra_Vector(*AssemblyMap) );

        row_scaling->PutScalar(1.0);
        col_scaling->PutScalar(1.0);
    }

    setPostParameters();

    params=*paramList;
}

//=============================================================================
THCM::~THCM()
{
    INFO("THCM destructor");
    FNAME(finalize)();
    if (Comm->MyPID()==0)
    {
        F90NAME(m_global,finalize)();
    }

    delete [] jcoA;
    delete [] coA;
    delete [] begA;

    delete [] coB;

    delete [] jcoF;
    delete [] coF;
    delete [] begF;
    // the rest is handled by Teuchos::rcp's
}

//=============================================================================
Teuchos::RCP<Epetra_Vector> THCM::getSolution()
{
    return initialSolution;
}

//=============================================================================
Teuchos::RCP<Epetra_CrsMatrix> THCM::getJacobian()
{
    return Jac;
}

//=============================================================================
// Compute and get the forcing
bool THCM::computeForcing()
{
    if (localFrc->Filled())
        localFrc->PutScalar(0.0); // set all matrix entries to zero

    const int maxlen = 1; // only 1 element per row
    int indices[maxlen];
    double values[maxlen];

    int index, numentries;

    int NumMyElements = AssemblyMap->NumMyElements();
    int imax = NumMyElements;
    std::vector<int> MyElements;

    FNAME(stochastic_forcing)();

    for (int i = 0; i < imax; i++)
    {
#ifndef NO_INTCOND
        if (sres == 0 && AssemblyMap->GID(i) == rowintcon_)
            continue;
#endif
        if (domain->IsGhost(i, _NUN_))
            continue;

        index = begF[i]; // note that these arrays use 1-based indexing
        numentries = begF[i+1] - index;
        for (int j = 0; j <  numentries ; j++)
        {
            indices[j] = AssemblyMap->GID(jcoF[index-1+j] - 1);
            values[j]  = coF[index - 1 + j];
            MyElements.push_back(indices[j]);
        }

        if (localFrc->Filled())
        {
            int ierr = localFrc->ReplaceGlobalValues(AssemblyMap->GID(i), numentries,
                                                     values, indices);

            // ierr == 3 probably means not all row entries are replaced,
            // does not matter because we zeroed them.
            if (((ierr!=0) && (ierr!=3)))
            {
                std::cout << "\n ERROR " << ierr;
                std::cout << "\n myPID " << Comm->MyPID();
                std::cout <<"\n while inserting/replacing values in local Jacobian"
                          << std::endl;

                INFO(" ERROR while inserting/replacing values in local Jacobian");

                int GRID = AssemblyMap->GID(i);
                std::cout << " GRID: " << GRID << std::endl;
                std::cout << " max GRID: " << AssemblyMap->GID(imax-1) << std::endl;
                std::cout << " number of entries: " << numentries << std::endl;

                std::cout << " entries: ";
                for (int j = 0; j < numentries; j++)
                    std::cout << "(" << indices[j] << " " << values[j] << ") ";
                std::cout << std::endl;

                std::cout << " NumMyElements:        " << NumMyElements << std::endl;
                std::cout << " i:                    " << i << std::endl;
                std::cout << " imax:                 " << imax << std::endl;
                std::cout << " maxlen:               " << maxlen << std::endl;

                std::cout << " row:                  " << GRID << std::endl;
                int LRID = localFrc->LRID(GRID);
                std::cout << " LRID:                 " << LRID << std::endl;
                std::cout << " graph inds in LRID:   "
                          << localFrc->Graph().NumMyIndices(LRID) << std::endl;

                int ierr2 = localFrc->ExtractGlobalRowCopy(
                    AssemblyMap->GID(i), maxlen, numentries, values, indices);

                std::cout << "\noriginal row: " << std::endl;
                std::cout << "number of entries: " << numentries << std::endl;
                std::cout << "entries: ";

                for (int j=0; j < numentries; j++)
                    std::cout << "(" << indices[j] << " " << values[j] << ") ";
                std::cout << std::endl;

                CHECK_ZERO(ierr2);
            }
        }
        else
        {
            CHECK_ZERO(localFrc->InsertGlobalValues(AssemblyMap->GID(i), numentries,
                                                    values, indices));
        }
    } //i-loop over rows

    auto last = std::unique(MyElements.begin(), MyElements.end());
    Epetra_Map colMap(-1, (int)std::distance(MyElements.begin(), last),
                      &MyElements[0], 0, *Comm);
    CHECK_ZERO(localFrc->FillComplete(colMap, *StandardMap));

    // redistribute according to SolveMap (may be load-balanced)
    // standard and solve maps are equal
    domain->Standard2Solve(*localFrc, *Frc);     // no effect
    CHECK_ZERO(Frc->FillComplete(colMap, *SolveMap));

    return true;
}

Teuchos::RCP<Epetra_CrsMatrix> THCM::getForcing()
{
    return Frc;
}

//=============================================================================
// Compute Jacobian and/or RHS.
bool THCM::evaluate(const Epetra_Vector& soln,
                    Teuchos::RCP<Epetra_Vector> tmp_rhs,
                    bool computeJac,
                    bool maskTest)
{
    if (comp_sal_int)
    {
        double intcond;
        CHECK_ZERO(intcond_coeff->Dot(soln,&intcond));
        intcond -= intCorrection_; // apply correction

        // INFO("Salinity integral condition: " << intcond);

    }

    if (!(soln.Map().SameAs(*SolveMap)))
    {
        ERROR("Map of solution vector not same as solve-map ",__FILE__,__LINE__);
    }


    // convert to standard distribution and
    // import values from ghost-nodes on neighbouring subdomains:
    domain->Solve2Assembly(soln,*localSol);


    int NumMyElements = AssemblyMap->NumMyElements();

//  DEBUG("=== evaluate: input vector");
//  DEBUG( (domain->Gather(*soln,0)) )

    // extract an array to pass on to THCM:
    // We use 'Copy' mode, which is clean but possibly slow.
    // Probably 'View' would be allowable as well.
    double* solution;
    localSol->ExtractView(&solution);
    if(tmp_rhs!=Teuchos::null)
    {
        // INFO("Compute RHS...");
        // build rhs simultaneously on each process
        double* RHS;
        CHECK_ZERO(localRhs->ExtractView(&RHS));
        TIMER_START("Ocean: compute rhs: fortran part");
        // compute right-hand-side on whole subdomain (by THCM)
        FNAME(rhs)(solution, RHS);
        TIMER_STOP("Ocean: compute rhs: fortran part");

        // export overlapping rhs to unique-id global rhs vector,
        // and load-balance for solve phase:
        domain->Assembly2Solve(*localRhs,*tmp_rhs);

        // Negating the RHS... Instead of scaling the RHS, scaling the
        // Jacobian corresponds better to how the equations would be
        // written.
        CHECK_ZERO(tmp_rhs->Scale(-1.0));

#ifndef NO_INTCOND
        if ((sres == 0) && !maskTest)
        {
            double intcond;
            //TODO: check which is better:
            CHECK_ZERO(intcond_coeff->Dot(soln,&intcond));
            //std::cout << " dot product: "<<intcond << std::endl;
            //intcond = 0.0;
            if (tmp_rhs->Map().MyGID(rowintcon_))
            {
                (*tmp_rhs)[tmp_rhs->Map().LID(rowintcon_)] =
                    intSign_ * (intcond - intCorrection_);
            }
        }
#endif
        if (rowPfix1>=0)
        {
            if (tmp_rhs->Map().MyGID(rowPfix1))
            {
                (*tmp_rhs)[tmp_rhs->Map().LID(rowPfix1)]=0.0;
            }
        }
        if (rowPfix2>=0)
        {
            if (tmp_rhs->Map().MyGID(rowPfix2))
            {
                (*tmp_rhs)[tmp_rhs->Map().LID(rowPfix2)]=0.0;
            }
        }
    }
    if(computeJac)
    {
        // INFO("Compute Jacobian...");
        Teuchos::RCP<Epetra_CrsMatrix> tmpJac;
        if (maskTest) // Use Jacobian based on testing graph
            tmpJac = testJac;
        else // Use Jacobian based on standard graph
            tmpJac = localJac;

        tmpJac->PutScalar(0.0); // set all matrix entries to zero
        localDiagB->PutScalar(0.0);

        if (sigmaUVTS || sigmaWP) {
            ERROR("We do not allow THCM to shift the matrix anymore!",
                  __FILE__,__LINE__);
        }

        //Call the fortran routine, providing the solution vector,
        //and get back the three vectors of the sparse Jacobian (CSR form)
        TIMER_START("Ocean: compute jacobian: fortran part");

        // If we test the mask we need non-restoring conditions in the matrix
        if (maskTest)
        {
            int tmp_sres = 0;
            FNAME(setsres)(&tmp_sres);
        }

        FNAME(matrix)(solution);

        // Restore from the testing config
        if (maskTest)
            FNAME(setsres)(&sres);

        TIMER_STOP("Ocean: compute jacobian: fortran part");

        const int maxlen = _NUN_*_NP_+1;    //nun*np+1 is max nonzeros per row
        int indices[maxlen];
        double values[maxlen];

        int index, numentries;

        int imax = NumMyElements;

        for (int i = 0; i < imax; i++)
        {
            if (!domain->IsGhost(i, _NUN_) &&
                ( ( AssemblyMap->GID(i) != rowintcon_ ) || maskTest ) )
            {
                index = begA[i]; // note that these arrays use 1-based indexing
                numentries = begA[i+1] - index;
                for (int j = 0; j <  numentries ; j++)
                {
                    indices[j] = AssemblyMap->GID(jcoA[index-1+j] - 1);
                    values[j]  = coA[index - 1 + j];
                }

                int ierr = tmpJac->ReplaceGlobalValues(AssemblyMap->GID(i), numentries,
                                                         values, indices);

                // ierr == 3 probably means not all row entries are replaced,
                // does not matter because we zeroed them.
                if (((ierr!=0) && (ierr!=3)))
                {
                    std::stringstream ss;
                    ss << "graph_pid" << Comm->MyPID();
                    std::ofstream file(ss.str());
                    file << tmpJac->Graph();

                    std::cout << "\n ERROR " << ierr;
                    std::cout << ((ierr == 2) ? ": value excluded" : "") << std::endl;
                    std::cout << "\n myPID " << Comm->MyPID();
                    std::cout <<"\n while inserting/replacing values in local Jacobian"
                              << std::endl;

                    INFO(" ERROR while inserting/replacing values in local Jacobian");

                    int GRID = AssemblyMap->GID(i);
                    std::cout << " GRID: " << GRID << std::endl;
                    std::cout << " max GRID: " << AssemblyMap->GID(imax-1) << std::endl;
                    std::cout << " number of entries: " << numentries << std::endl;

                    std::cout << " entries: ";
                    for (int j = 0; j < numentries; j++)
                        std::cout << "(" << indices[j] << " " << values[j] << ") ";
                    std::cout << std::endl;

                    std::cout << " NumMyElements:        " << NumMyElements << std::endl;
                    std::cout << " i:                    " << i << std::endl;
                    std::cout << " imax:                 " << imax << std::endl;
                    std::cout << " maxlen:               " << maxlen << std::endl;

                    std::cout << " row:                  " << GRID << std::endl;
                    std::cout << " have rowintcon:       " << tmpJac->MyGRID(rowintcon_)
                              << std::endl;
                    std::cout << " rowintcon:            " << rowintcon_ << std::endl;
                    std::cout << " assembly rowintcon:   " << AssemblyMap->LID(rowintcon_)
                              << std::endl;
                    std::cout << " standard rowintcon:   " << StandardMap->LID(rowintcon_)
                              << std::endl;
                    int LRID = tmpJac->LRID(GRID);
                    std::cout << " LRID:                 " << LRID << std::endl;
                    std::cout << " graph inds in LRID:   "
                              << tmpJac->Graph().NumMyIndices(LRID) << std::endl;

                    int ierr2 = tmpJac->ExtractGlobalRowCopy
                        (AssemblyMap->GID(i), maxlen, numentries, values, indices);

                    std::cout << "\noriginal row: " << std::endl;
                    std::cout << "number of entries: " << numentries << std::endl;
                    std::cout << "entries: ";

                    for (int j=0; j < numentries; j++)
                        std::cout << "(" << indices[j] << " " << values[j] << ") ";
                    std::cout << std::endl;

                    CHECK_ZERO(ierr2);
                }

                // reconstruct the diagonal matrix B
                int lid = StandardMap->LID(AssemblyMap->GID(i));
                double mass_param = 1.0;
                this->getParameter("Mass", mass_param);
                (*localDiagB)[lid] = coB[i] * mass_param;
            } //not a ghost?
        } //i-loop over rows

#ifndef NO_INTCOND
        if ((sres == 0) && !maskTest)
        {
            this->intcond_S(*tmpJac,*localDiagB);
        }
#endif

        if (fixPressurePoints_)
            this->fixPressurePoints(*tmpJac,*localDiagB);

        CHECK_ZERO(tmpJac->FillComplete());

        // redistribute according to SolveMap (may be load-balanced)
        // standard and solve maps are equal
        domain->Standard2Solve(*localDiagB, *diagB); // no effect
        domain->Standard2Solve(*tmpJac, *Jac);     // no effect
        CHECK_ZERO(Jac->FillComplete());

        if (scaling_type == "THCM")
        {
            DEBUG(" THCM:  RecomputeScaling()");
            this->RecomputeScaling();

#if 0
            std::ofstream ofs1("row_scaling.txt");
            ofs1 << *row_scaling;
            ofs1.close();
            std::ofstream ofs2("col_scaling.txt");
            ofs2 << *col_scaling;
            ofs2.close();
#endif
        }

    } // matrix
    return true;
}

// just reconstruct the diagonal matrix B from THCM
void THCM::evaluateB(void)
{
    int NumMyElements = AssemblyMap->NumMyElements();

    DEBUG("Construct matrix B...");

    localDiagB->PutScalar(0.0);
    FNAME(fillcolb)();
    for (int i = 0; i < NumMyElements; i++)
    {
        if (!domain->IsGhost(i, _NUN_))
        {
            // reconstruct the diagonal matrix B
            int lid = StandardMap->LID(AssemblyMap->GID(i));
            (*localDiagB)[lid] = coB[i];
        } // not a ghost?
    } // i-loop over rows

    if (fixPressurePoints_)
    {
        for (int i=1;i<=2;i++) {
            int row = (i==1)? rowPfix1: rowPfix2;
            if (localDiagB->Map().MyGID(row))
            {
                int lid = localDiagB->Map().LID(row);
                (*localDiagB)[lid] = 0.0; // no more time-dependence for this P-point
            }
        }
    }

#ifndef NO_INTCOND
    if (sres == 0)
    {
        if (localDiagB->Map().MyGID(rowintcon_))
        {
            (*localDiagB)[localDiagB->Map().LID(rowintcon_)]=0.0;
        }
    }
#endif
    domain->Standard2Solve(*localDiagB,*diagB);
}

//==================================================================
// Get current global landmask including borders
std::shared_ptr<std::vector<int> > THCM::getLandMask()
{
    // length of landmask array
    int dim = (n+2)*(m+2)*(l+2);

    // Create landmask array
    std::shared_ptr<std::vector<int> > landm =
        std::make_shared<std::vector<int> >(dim, 0);

    // Let THCM fill the landmask array on proc = 0
    if (Comm->MyPID() == 0)
        F90NAME(m_global, get_current_landm)(&(*landm)[0]);

    // Get the MpiComm from Epetra
    Epetra_MpiComm const MpiComm =
        dynamic_cast<Epetra_MpiComm const &>(*Comm);

    // Broadcast the landmask
    MPI_Bcast(&(*landm)[0], dim, MPI_INTEGER, 0, MpiComm.GetMpiComm());

    return landm;
}

//=============================================================================
// Get distributed land mask based on maskName
Teuchos::RCP<Epetra_IntVector> THCM::getLandMask(std::string const &maskName,
                                                 Teuchos::RCP<Epetra_Vector> fix)
{
    if (Comm->MyPID() == 0)
    {
        // Write mask name to file, fortran code will read it from there
        std::ofstream ofs("mask_name.txt", std::ios::trunc);
        ofs << maskName;
    }

    // Create gathered map for land mask
    // All indices are on root process
    int I0 = 0; int I1 = n+1;
    int J0 = 0; int J1 = m+1;
    int K0 = 0; int K1 = l+1;

    int i0 = 0, i1 = -1, j0 = 0, j1 = -1,k0 = 0,k1 = -1;
    if (Comm->MyPID() == 0)
    {
        i1 = I1; j1 = J1; k1=K1;
    }

    Teuchos::RCP<Epetra_Map> landmap_glb =
        Utils::CreateMap(i0,i1,j0,j1,k0,k1,I0,I1,J0,J1,K0,K1,*Comm);

    // Create sequential landmask array on proc 0
    Teuchos::RCP<Epetra_IntVector> landm_glb =
        Teuchos::rcp(new Epetra_IntVector(*landmap_glb));

    // Get global landmask from fortran
    int *landm;
    if (Comm->MyPID()==0)
    {
        CHECK_ZERO(landm_glb->ExtractView(&landm));

        // Let THCM fill the global landm array and put it into our C pointer location
        if (maskName == "current")
            F90NAME(m_global,get_current_landm)(landm);
        else
            F90NAME(m_global,get_landm)(landm);
    }

    // Fixing landmask
    if (fix != Teuchos::null)
    {
        // Gather fix on proc 0
        Teuchos::RCP<Epetra_MultiVector> fix0 =
            Utils::Gather(*fix, 0);

        int len = fix0->Map().NumMyElements();

        std::vector<double> fix1(len);
        (*fix0)(0)->ExtractCopy(&fix1[0]);

        int i,j,k;
        if (Comm->MyPID() == 0 && len > 0)
        {
            int pos = 0;
            int idx = 0;
            for (k = K0+1; k < K1; ++k)
            {
                for (j = J0+1; j < J1; ++j)
                {
                    for (i = I0+1; i < I1; ++i)
                    {
                        idx = k*(m+2)*(n+2) + j*(n+2) + i;

                        // magic number 2 indicates too little
                        // contributions in the corresponding matrix
                        // row
                        if (fix1[pos] == 2)
                            landm[idx] = 1; // adjust landmask

                        pos++;
                    }
                }
            }

            // Setting fixed global landmask in THCM
            F90NAME(m_global, set_landm)(landm);
        }
    }

    // Return distributed landmask
    Teuchos::RCP<Epetra_IntVector> landm_loc = distributeLandMask(landm_glb);

    return landm_loc;
}

//=============================================================================
// Set distributed landmask in THCM
// set_landmask takes care of a few reinitializations if requested
void THCM::setLandMask(Teuchos::RCP<Epetra_IntVector> landmask, bool init)
{
    // in the main part of THCM (except m_global) we set periodic
    // boundary conditions to .false. _unless_ we are running a
    // periodic problem on a single CPU in the x-direction:
    Teuchos::RCP<Epetra_Comm> xComm = domain->GetProcRow(0);
    int perio   = (periodic && xComm->NumProc() == 1);

    int *landm;
    CHECK_ZERO(landmask->ExtractView(&landm));

    int reinit = (init) ? 1 : 0;
    FNAME(set_landmask)(landm, &perio, &reinit);
}

//=============================================================================
// Set global landmask in THCM
void THCM::setLandMask(std::shared_ptr<std::vector<int> > landmask)
{
    if (Comm->MyPID() == 0)
        F90NAME(m_global, set_landm)(&(*landmask)[0]);
}

//=============================================================================
void THCM::setAtmosphereT(Teuchos::RCP<Epetra_Vector> const &atmosT)
{
    CHECK_MAP(atmosT, StandardSurfaceMap);
    // Standard2Assembly
    // Import atmosT into local atmosT
    CHECK_ZERO(localAtmosT->Import(*atmosT, *as2std_surf, Insert));

    double *locAtmosT;

    localAtmosT->ExtractView(&locAtmosT);
    F90NAME(m_inserts, insert_atmosphere_t)( locAtmosT );
}

//=============================================================================
void THCM::setAtmosphereQ(Teuchos::RCP<Epetra_Vector> const &atmosQ)
{
    CHECK_MAP(atmosQ, StandardSurfaceMap);

    // Standard2Assembly
    // Import atmosQ into local atmosQ
    CHECK_ZERO( localAtmosQ->Import(*atmosQ, *as2std_surf, Insert) );

    double *tmpAtmosQ;
    localAtmosQ->ExtractView(&tmpAtmosQ);
    F90NAME(m_inserts, insert_atmosphere_q)( tmpAtmosQ );
}

//=============================================================================
void THCM::setAtmosphereA(Teuchos::RCP<Epetra_Vector> const &atmosA)
{
    CHECK_MAP(atmosA, StandardSurfaceMap);

    // Standard2Assembly
    // Import atmosQ into local atmosQ
    CHECK_ZERO( localAtmosA->Import(*atmosA, *as2std_surf, Insert) );

    double *tmpAtmosA;
    localAtmosA->ExtractView(&tmpAtmosA);
    F90NAME(m_inserts, insert_atmosphere_a)( tmpAtmosA );
}

//=============================================================================
void THCM::setAtmosphereP(Teuchos::RCP<Epetra_Vector> const &atmosP)
{
    CHECK_MAP(atmosP, StandardSurfaceMap);

    // Import atmosP into local atmosP
    CHECK_ZERO(localAtmosP->Import(*atmosP, *as2std_surf, Insert));

    double *tmpAtmosP;
    localAtmosP->ExtractView(&tmpAtmosP);

    F90NAME(m_inserts, insert_atmosphere_p)( tmpAtmosP );
}

//=============================================================================
void THCM::setSeaIceQ(Teuchos::RCP<Epetra_Vector> const &seaiceQ)
{
    CHECK_MAP(seaiceQ, StandardSurfaceMap);
    CHECK_ZERO(localSeaiceQ->Import(*seaiceQ, *as2std_surf ,Insert));
    double *Q;
    localSeaiceQ->ExtractView(&Q);
    F90NAME(m_inserts, insert_seaice_q)( Q );
}

//=============================================================================
void THCM::setSeaIceM(Teuchos::RCP<Epetra_Vector> const &seaiceM)
{
    CHECK_MAP(seaiceM, StandardSurfaceMap);
    CHECK_ZERO(localSeaiceM->Import(*seaiceM, *as2std_surf ,Insert));
    double *M;

    if (!coupled_M)
        localSeaiceM->PutScalar(0.0); // disable coupling with mask

    localSeaiceM->ExtractView(&M);
    F90NAME(m_inserts, insert_seaice_m)( M );
}

//=============================================================================
void THCM::setSeaIceG(Teuchos::RCP<Epetra_Vector> const &seaiceG)
{
    CHECK_MAP(seaiceG, StandardSurfaceMap);
    CHECK_ZERO(localSeaiceG->Import(*seaiceG, *as2std_surf ,Insert));
    double *G;
    localSeaiceG->ExtractView(&G);
    F90NAME(m_inserts, insert_seaice_g)( G );
}

//=============================================================================
//FIXME: superfluous?? ->setAtmosphereT()
void THCM::setTatm(Teuchos::RCP<Epetra_Vector> const &tatm)
{

    if (!(tatm->Map().SameAs(*StandardSurfaceMap)))
    {
        // INFO("THCM::setAtmosphereEP: atmosP map -> StandardSurfaceMap");
        CHECK_ZERO(tatm->ReplaceMap(*StandardSurfaceMap));
    }

    // Standard2Assembly
    // Import atmosP into local atmosP
    CHECK_ZERO(localTatm->Import(*tatm, *as2std_surf, Insert));

    double *tmpTatm;
    localTatm->ExtractView(&tmpTatm);

    F90NAME(m_inserts, insert_tatm)( tmpTatm );
}

//=============================================================================
void THCM::setEmip(Teuchos::RCP<Epetra_Vector> const &emip, char mode)
{

    if (!(emip->Map().SameAs(*StandardSurfaceMap)))
    {
        INFO("THCM::setEmip: emip map -> StandardSurfaceMap");
        CHECK_ZERO(emip->ReplaceMap(*StandardSurfaceMap));
    }

    // Standard2Assembly
    // Import atmosP into local atmosP
    CHECK_ZERO(localSurfTmp->Import(*emip, *as2std_surf, Insert));

    double *tmpEmip;
    localSurfTmp->ExtractView(&tmpEmip);

    if (mode == 'A')
    {
        F90NAME(m_inserts, insert_adapted_emip )( tmpEmip );
    }
    else if (mode == 'P')
    {
        F90NAME(m_inserts, insert_emip_pert )( tmpEmip );
    }
    else
    {
        F90NAME(m_inserts, insert_emip )( tmpEmip );
    }
}

//=============================================================================
Teuchos::RCP<Epetra_Vector> THCM::getSunO()
{
    double *suno;
    Epetra_Vector localSunO(*AssemblySurfaceMap);
    localSunO.ExtractView(&suno);
    F90NAME(m_probe, get_suno) ( suno );
    Teuchos::RCP<Epetra_Vector> out =
        Teuchos::rcp(new Epetra_Vector(*StandardSurfaceMap));
    CHECK_ZERO(out->Export(localSunO, *as2std_surf, Zero));
    return out;
}

//=============================================================================
Teuchos::RCP<Epetra_Vector> THCM::getEmip(char mode)
{
    double* tmpEmip;
    localSurfTmp->ExtractView(&tmpEmip);

    if (mode == 'A')
    {
        F90NAME(m_probe, get_adapted_emip )( tmpEmip );
    }
    else if (mode == 'P')
    {
        F90NAME(m_probe, get_emip_pert )( tmpEmip );
    }
    else
    {
        F90NAME(m_probe, get_emip )( tmpEmip );
    }


    Teuchos::RCP<Epetra_Vector> emip =
        Teuchos::rcp(new Epetra_Vector(*StandardSurfaceMap));

    // Export assembly map surface emip
    CHECK_ZERO(emip->Export(*localEmip, *as2std_surf, Zero));

    return emip;
}

//=============================================================================
std::vector<Teuchos::RCP<Epetra_Vector> > THCM::getFluxes()
{
    int numFluxes = _MSI+1;

    std::vector<Teuchos::RCP<Epetra_Vector> > fluxes;
    std::vector<Epetra_Vector> localFluxes;

    for (int i = 0; i != numFluxes; ++i)
    {
        fluxes.push_back(Teuchos::rcp(new Epetra_Vector(*StandardSurfaceMap)));
        localFluxes.push_back(Epetra_Vector(*AssemblySurfaceMap));
    }

    std::vector<double*> tmpPtrs(numFluxes);

    for (int i = 0; i != numFluxes; ++i)
        localFluxes[i].ExtractView(&tmpPtrs[i]);

    double* solution;
    localSol->ExtractView(&solution);

    F90NAME(m_probe, get_salflux )( solution, tmpPtrs[_Sal],  &scorr_,
                                    tmpPtrs[_QSOA], tmpPtrs[_QSOS] );

    F90NAME(m_probe, get_temflux )( solution, tmpPtrs[_Temp], tmpPtrs[_QSW],
                                    tmpPtrs[_QSH], tmpPtrs[_QLH], tmpPtrs[_QTOS],
                                    tmpPtrs[_MSI] );

    for (int i = 0; i != numFluxes; ++i)
    {
        CHECK_ZERO(fluxes[i]->Export(localFluxes[i], *as2std_surf, Zero));
    }

    return fluxes;
}

//=============================================================================
THCM::Derivatives THCM::getDerivatives()
{
    Derivatives d;

    double *solution;
    localSol->ExtractView(&solution);

    Epetra_Vector local_dftdm(*AssemblySurfaceMap);
    Epetra_Vector local_dfsdq(*AssemblySurfaceMap);
    Epetra_Vector local_dfsdm(*AssemblySurfaceMap);
    Epetra_Vector local_dfsdg(*AssemblySurfaceMap);

    double *dftdm, *dfsdq, *dfsdm, *dfsdg;
    local_dftdm.ExtractView(&dftdm);
    local_dfsdq.ExtractView(&dfsdq);
    local_dfsdm.ExtractView(&dfsdm);
    local_dfsdg.ExtractView(&dfsdg);
    F90NAME(m_probe, get_derivatives)( solution, dftdm, dfsdq, dfsdm, dfsdg);

    d.dFTdM = Teuchos::rcp(new Epetra_Vector(*StandardSurfaceMap));
    d.dFSdQ = Teuchos::rcp(new Epetra_Vector(*StandardSurfaceMap));
    d.dFSdM = Teuchos::rcp(new Epetra_Vector(*StandardSurfaceMap));
    d.dFSdG = Teuchos::rcp(new Epetra_Vector(*StandardSurfaceMap));

    d.dFTdM->Export(local_dftdm, *as2std_surf, Zero);
    d.dFSdQ->Export(local_dfsdq, *as2std_surf, Zero);
    d.dFSdM->Export(local_dfsdm, *as2std_surf, Zero);
    d.dFSdG->Export(local_dfsdg, *as2std_surf, Zero);

    return d;
}

//=============================================================================
Teuchos::RCP<Epetra_Vector> THCM::getLocalAtmosT()
{
    double *tmpAtmosT;
    localAtmosT->ExtractView(&tmpAtmosT);
    F90NAME(m_probe, get_atmosphere_t )( tmpAtmosT );
    return localAtmosT;
}

//=============================================================================
Teuchos::RCP<Epetra_Vector> THCM::getLocalAtmosQ()
{
    double *tmpAtmosQ;
    localAtmosP->ExtractView(&tmpAtmosQ);
    F90NAME(m_probe, get_atmosphere_q )( tmpAtmosQ );
    return localAtmosQ;
}

//=============================================================================
Teuchos::RCP<Epetra_Vector> THCM::getAtmosQ()
{
    Teuchos::RCP<Epetra_Vector> atmosQ =
        Teuchos::rcp(new Epetra_Vector(*StandardSurfaceMap));

    // Export assembly map surface evaporation to standard surface map
    CHECK_ZERO(atmosQ->Export(*getLocalAtmosQ(), *as2std_surf, Zero));
    return atmosQ;
}

//=============================================================================
Teuchos::RCP<Epetra_Vector> THCM::getLocalAtmosP()
{
    double *tmpAtmosP;
    localAtmosP->ExtractView(&tmpAtmosP);
    F90NAME(m_probe, get_atmosphere_p )( tmpAtmosP );
    return localAtmosP;
}

//============================================================================
Teuchos::RCP<Epetra_Vector> THCM::getLocalOceanE()
{
    double *tmpOceanE;
    localOceanE->ExtractView(&tmpOceanE);

    // localsol should contain something meaningful
    double* solution;
    localSol->ExtractView(&solution);

    F90NAME( m_probe, compute_evap )( tmpOceanE, solution );

    return localOceanE;
}

//============================================================================
Teuchos::RCP<Epetra_Vector> THCM::getOceanE()
{
    Teuchos::RCP<Epetra_Vector> oceanE =
        Teuchos::rcp(new Epetra_Vector(*StandardSurfaceMap));

    // Export assembly map surface evaporation to standard surface map
    CHECK_ZERO(oceanE->Export(*getLocalOceanE(), *as2std_surf, Zero));
    return oceanE;
}

//=============================================================================
// Recompute scaling for the linear system
void THCM::RecomputeScaling(void)
{

    DEBUG("Compute new scaling...");

    // (1) THCM block scaling

    // array to be filled by F90 routine
    // (average diagonal block, 6x6)
    double ldb[_NUN_*_NUN_];
    double gdb[_NUN_*_NUN_];

    int len = local_row_scaling->MyLength();
    double *rowscal = new double[len];
    double *colscal = new double[len];

    // compute local average diagonal block
    F90NAME(m_scaling,average_block)(ldb);

    Comm->SumAll(ldb,gdb,_NUN_*_NUN_);

    for (int i=0;i<_NUN_*_NUN_;i++)
    {
        gdb[i]/=Comm->NumProc();
    }
    // compute row- and column scaling
    F90NAME(m_scaling,compute)(gdb,rowscal,colscal);

    // put them back in assembly vectors:
    // note: the scaling matrices in Trilinos are
    // defined as the inverse of those in THCM
    for (int i=0;i<len;i++)
    {
        (*local_row_scaling)[i] = 1.0/rowscal[i];
        (*local_col_scaling)[i] = 1.0/colscal[i];
    }

    // kick out the ghost nodes:
    domain->Assembly2Solve(*local_row_scaling,*row_scaling);
    domain->Assembly2Solve(*local_col_scaling,*col_scaling);

    // make sure T and S are scaled the same way in each cell
    // we need this because of our special block scaling for the
    // ATS matrix in the preconditioner.
    for (int i = TT-1; i < row_scaling->MyLength(); i += _NUN_)
    {
        double mean = 0.5*((*row_scaling)[i]+(*row_scaling)[i+1]);
        (*row_scaling)[i] = mean;
        (*row_scaling)[i+1] = mean;
        mean = 0.5*((*col_scaling)[i]+(*col_scaling)[i+1]);
        (*col_scaling)[i] = mean;
        (*col_scaling)[i+1] = mean;
    }

    delete [] rowscal;
    delete [] colscal;

    // (2) diagonal row scaling for T and S (obsolete!)
    if (row_scaling_TS!=Teuchos::null)
    {
        CHECK_ZERO(Jac->ExtractDiagonalCopy(*row_scaling_TS));
        for (int i=0;i<row_scaling_TS->MyLength();i+=_NUN_)
        {
            for (int j=i;j<i+4;j++)
            {
                (*row_scaling_TS)[j] = 1.0; //u,v,w,p
            }
            for (int j=i+4;j<i+6;j++)
            {
                (*row_scaling_TS)[j] = 1.0/(*row_scaling_TS)[j]; //T,S
            }
        }
    }// additional T/S scaling (obsolete)
}

//=============================================================================
void THCM::normalizePressure(Epetra_Vector& soln) const
{
    int i = n/2-1;
    int j = 6*m/8-1;
    int k = l-1;
    int ref_gid = FIND_ROW2(_NUN_,n,m,l,i,j,k,PP);
    int ref_lid, ref_host;
    double ref_value;
    soln.Map().RemoteIDList(1, &ref_gid, &ref_host, &ref_lid);

    DEBUG("+++ NORMALIZE P +++\n");
    DEBVAR(ref_gid);
    DEBVAR(ref_lid);
    DEBVAR(ref_host);
    DEBUG("+++++++++++++++++++\n");

    if (ref_lid>=0) ref_value = soln[ref_lid];
    soln.Comm().Broadcast (&ref_value, 1, ref_host);

    //subtract reference value from all 'P' points except land cells
    // TODO: 1) we do not handle land cells correctly here, yet!
    //       2) the whole thing seems to go wrong...
    //  for (int i=PP;i<=soln.MyLength();i+=_NUN_) soln[i-1] -= ref_value;
}

//=============================================================================
// Timing functionality
void THCM::startTiming(std::string fname)
{
    Teuchos::RCP<Epetra_Time> T=Teuchos::rcp(new Epetra_Time(*Comm));
    timerList.sublist("timers").set(fname,T);
}


//=============================================================================
void THCM::stopTiming(std::string fname,bool print)
{
    Teuchos::RCP<Epetra_Time> T = Teuchos::null;
    T=timerList.sublist("timers").get(fname,T);
    double elapsed=0;
    if (T!=Teuchos::null)
    {
        elapsed=T->ElapsedTime();
    }
    int ncalls=timerList.sublist("number of calls").get(fname,0);
    double total_time=timerList.sublist("total time").get(fname,0.0);
    timerList.sublist("number of calls").set(fname,ncalls+1);
    timerList.sublist("total time").set(fname,total_time+elapsed);
    if (print)
    {
        (std::cout) << "### timing: "<<fname<<" "<<elapsed<<std::endl;
    }
}

//=============================================================================
void THCM::printTiming(std::ostream& os)
{
    os << "================= TIMING RESULTS ====================="<<std::endl;
    os << "     Description                              ";
    os << " # Calls \t Cumulative Time \t Time/call\n";
    os << "======================================================"<<std::endl;

    Teuchos::ParameterList& ncallsList=timerList.sublist("number of calls");
    Teuchos::ParameterList& elapsedList=timerList.sublist("total time");
    for (Teuchos::ParameterList::ConstIterator i=ncallsList.begin();i!=ncallsList.end();i++)
    {
        const std::string& fname = i->first;
        int ncalls = ncallsList.get(fname,0);
        double elapsed = elapsedList.get(fname,0.0);
        os << fname << "\t" <<ncalls<<"\t"<<elapsed<<"\t"
           << ((ncalls>0)? elapsed/(double)ncalls : 0.0) <<std::endl;
    }
    os << "====================================================="<<std::endl;
    DEBUG(timerList);
}

//=============================================================================
double THCM::defaultParameter(std::string const &label)
{
    //FIXME: Discuss how to better handle default value for AL_T being
    //initalised in Fortran code.
    if (label == "AL_T")                           return std::numeric_limits<double>::quiet_NaN();
    if (label == "Rayleigh-Number")                return 4.219587324359678e-2;
    if (label == "Vertical Ekman-Number")          return 4.2855183763027976e-7;
    if (label == "Horizontal Ekman-Number")        return 4.22458923801749e-5;
    if (label == "Rossby-Number")                  return 1.0764253378468565e-4;
    if (label == "SPL1")                           return 2000;
    if (label == "Solar Forcing")                  return 0;
    if (label == "Horizontal Peclet-Number")       return 1.5698587127158557e-3;
    if (label == "Vertical Peclet-Number")         return 3.98125e-4;
    if (label == "P_VC")                           return 9.95312;
    if (label == "LAMB")                           return 7.6;
    if (label == "Salinity Forcing")               return 1;
    if (label == "Wind Forcing")                   return 1;
    if (label == "Temperature Forcing")            return 10;
    if (label == "Nonlinear Factor")               return 9.830246913580247;
    if (label == "Combined Forcing")               return 0;
    if (label == "Energy")                         return 100;
    if (label == "ALPC")                           return 1;
    if (label == "SPL2")                           return 0.01;
    if (label == "Exponent")                       return 0.01;
    if (label == "Seasonal Forcing")               return 0.01;
    if (label == "Seasonal Forcing (Wind)")        return 0.01;
    if (label == "Seasonal Forcing (Temperature)") return 0.01;
    if (label == "Seasonal Forcing (Salinity)")    return 0.01;
    if (label == "Mass")                           return 0.01;

    return 0.0;
}

//=============================================================================
// convert parameter name to integer
int THCM::par2int(std::string const &label)
{
    // parameter numbering in fortran code
    int TIME   =  0;
    int AL_T   =  1; int RAYL   =  2; int EK_V   =  3; int EK_H   =  4;
    int ROSB   =  5; int MIXP   =  6; int RESC   =  7; int SPL1   =  8;
    int HMTP   =  9; int SUNP   = 10; int PE_H   = 11; int PE_V   = 12;
    int P_VC   = 13; int LAMB   = 14; int SALT   = 15; int WIND   = 16;
    int TEMP   = 17; int BIOT   = 18; int COMB   = 19; int ARCL   = 20;
    int NLES   = 21; int IFRICB = 22; int CONT   = 23; int ENER   = 24;
    int ALPC   = 25; int CMPR   = 26; int FPER   = 27; int SPER   = 28;
    int MKAP   = 29; int SPL2   = 30; int EXPO   = 31; int SEAS   = 32;
    int SEASW  = 33; int SEAST  = 34; int SEASS  = 35; int MASS   = 36;

    if      (label == "Time")                            return TIME;
    else if (label == "AL_T")                            return AL_T;
    else if (label == "Rayleigh-Number")                 return RAYL;
    else if (label == "Rossby-Number")                   return ROSB;
    else if (label == "Vertical Ekman-Number")           return EK_V;
    else if (label == "Horizontal Ekman-Number")         return EK_H;
    else if (label == "MIXP")                            return MIXP;
    else if (label == "RESC")                            return RESC;
    else if (label == "SPL1")                            return SPL1;
    else if (label == "Salinity Homotopy")               return HMTP;
    else if (label == "Solar Forcing")                   return SUNP;
    else if (label == "Vertical Peclet-Number")          return PE_V;
    else if (label == "Horizontal Peclet-Number")        return PE_H;
    else if (label == "P_VC")                            return P_VC;
    else if (label == "LAMB")                            return LAMB;
    else if (label == "ARCL")                            return ARCL;
    else if (label == "Salinity Forcing")                return SALT;
    else if (label == "Wind Forcing")                    return WIND;
    else if (label == "Temperature Forcing")             return TEMP;
    else if (label == "Nonlinear Factor")                return BIOT;
    else if (label == "Combined Forcing")                return COMB;
    else if (label == "CONT")                            return CONT;
    else if (label == "IFRICB")                          return IFRICB;
    else if (label == "NLES")                            return NLES;
    else if (label == "CMPR")                            return CMPR;
    else if (label == "ALPC")                            return ALPC;
    else if (label == "Energy")                          return ENER;
    else if (label == "Salinity Perturbation")           return SPER;
    else if (label == "Flux Perturbation")               return FPER;
    else if (label == "MKAP")                            return MKAP;
    else if (label == "SPL2")                            return SPL2;
    else if (label == "Exponent")                        return EXPO;
    else if (label == "Seasonal Forcing")                return SEAS;// combination of T,S and Wind
    else if (label == "Seasonal Forcing (Temperature)")  return SEAST;
    else if (label == "Seasonal Forcing (Salinity)")     return SEASS;
    else if (label == "Seasonal Forcing (Wind)")         return SEASW;
    else if (label == "Mass")                            return MASS;

    return -1;
}

//=============================================================================
// convert parameter name to integer
std::string const THCM::int2par(int index)
{
    std::string label = "Invalid Parameter Index";

    // parameter numbering in fortran code
    int TIME   =  0;
    int AL_T   =  1; int RAYL   =  2; int EK_V   =  3; int EK_H   =  4;
    int ROSB   =  5; int MIXP   =  6; int RESC   =  7; int SPL1   =  8;
    int HMTP   =  9; int SUNP   = 10; int PE_H   = 11; int PE_V   = 12;
    int P_VC   = 13; int LAMB   = 14; int SALT   = 15; int WIND   = 16;
    int TEMP   = 17; int BIOT   = 18; int COMB   = 19; int ARCL   = 20;
    int NLES   = 21; int IFRICB = 22; int CONT   = 23; int ENER   = 24;
    int ALPC   = 25; int CMPR   = 26; int FPER   = 27; int SPER   = 28;
    int MKAP   = 29; int SPL2   = 30; int EXPO   = 31; int SEAS   = 32;
    int SEASW  = 33; int SEAST  = 34; int SEASS  = 35; int MASS   = 36;

    if      (index==TIME)   label = "Time";
    else if (index==AL_T)   label = "AL_T";
    else if (index==RAYL)   label = "Rayleigh-Number";
    else if (index==EK_V)   label = "Vertical Ekman-Number";
    else if (index==EK_H)   label = "Horizontal Ekman-Number";
    else if (index==ROSB)   label = "Rossby-Number";
    else if (index==MIXP)   label = "MIXP";
    else if (index==RESC)   label = "RESC";
    else if (index==SPL1)   label = "SPL1";
    else if (index==HMTP)   label = "Salinity Homotopy";
    else if (index==SUNP)   label = "Solar Forcing";
    else if (index==PE_V)   label = "Vertical Peclet-Number";
    else if (index==PE_H)   label = "Horizontal Peclet-Number";
    else if (index==SALT)   label = "Salinity Forcing";
    else if (index==WIND)   label = "Wind Forcing";
    else if (index==TEMP)   label = "Temperature Forcing";
    else if (index==BIOT)   label = "Nonlinear Factor";
    else if (index==COMB)   label = "Combined Forcing";
    else if (index==NLES)   label = "NLES";
    else if (index==ARCL)   label = "ARCL";
    else if (index==IFRICB) label = "IFRICB";
    else if (index==CONT)   label = "CONT";
    else if (index==P_VC)   label = "P_VC";
    else if (index==LAMB)   label = "LAMB";
    else if (index==CMPR)   label = "CMPR";
    else if (index==ALPC)   label = "ALPC";
    else if (index==ENER)   label = "Energy";
    else if (index==MKAP)   label = "MKAP";
    else if (index==SPL2)   label = "SPL2";
    else if (index==FPER)   label = "Flux Perturbation";
    else if (index==SPER)   label = "Salinity Perturbation";
    else if (index==EXPO)   label = "Exponent";
    else if (index==SEAS)   label = "Seasonal Forcing";
    else if (index==SEASW)  label = "Seasonal Forcing (Wind)";
    else if (index==SEAST)  label = "Seasonal Forcing (Temperature)";
    else if (index==SEASS)  label = "Seasonal Forcing (Salinity)";
    else if (index==MASS)   label = "Mass";
    else
    {
        ERROR("Parameter index is invalid!",__FILE__,__LINE__);
    }
    return label;
}

//=============================================================================
bool THCM::setParameter(std::string label, double value)
{
    int param = par2int(label);
    if (param>0 && param<=_NPAR_) // time (0) and exp/seas (31/32) are not passed to THCM
    {
        FNAME(setparcs)(&param,&value);
    }
    else if (param<0)
    {
        ERROR("Invalid Parameter",__FILE__,__LINE__);
    }
    else if (param==0) // 0 is non-dimensional time
    {
        // set monthly forcing data
        bool time_dep_forcing = paramList->get<bool>("Time Dependent Forcing");
        if ((value>=0.0) && time_dep_forcing)
        {
            double gamma=1.0,gammaT=1.0,gammaS=1.0,gammaW=1.0;//default values
            this->getParameter("Seasonal Forcing",gamma);
            this->getParameter("Seasonal Forcing (Wind)",gammaW);
            this->getParameter("Seasonal Forcing (Temperature)",gammaT);
            this->getParameter("Seasonal Forcing (Salinity)",gammaS);
            gammaT*=gamma; gammaS*=gamma; gammaW*=gamma;
            INFO("Set THCM time to "<<value);
            INFO("Seasonal forcing parameters (W,T,S): "<<gammaW<<", "<<gammaT<<", "<<gammaS);
            F90NAME(m_monthly,update_forcing)(&value,&gammaW,&gammaT,&gammaS);
            if (internal_forcing)
            {
                F90NAME(m_monthly,update_internal_forcing)(&value,&gammaT,&gammaS);
            }

        }
        else if (value<0.0) //! reset to constant forcing (used in 4D FFT solver)
        {
            double gammaT=0.0,gammaS=0.0,gammaW=0.0,val=0.0;
            INFO("Set THCM forcing to constant");
            F90NAME(m_monthly,update_forcing)(&val,&gammaW,&gammaT,&gammaS);
            if (internal_forcing)
            {
                F90NAME(m_monthly,update_internal_forcing)(&val,&gammaT,&gammaS);
            }
        }
    }
    return true;
}

//=============================================================================
bool THCM::getParameter(std::string label, double& value)
{
    int param = par2int(label);
    if (param>0 && param<=_NPAR_) // time (0) and exp (_NPAR_+1) are not passed to THCM
    {
        FNAME(getparcs)(&param,&value);
    }
    // The rest is not implemented
    return true;
}

//=============================================================================
bool THCM::writeParams()
{
    FNAME(writeparams)();
    return true;
}

//=============================================================================
Teuchos::RCP<Epetra_IntVector> THCM::distributeLandMask(Teuchos::RCP<Epetra_IntVector> landm_glb)
{

    DEBUG("Create local (land-)maps...");

    // create a non-overlapping distributed map
    int i0 = domain->FirstRealI()+1; // 'grid-style' indexing is 1-based
    int i1 = domain->LastRealI()+1;
    int j0 = domain->FirstRealJ()+1;
    int j1 = domain->LastRealJ()+1;
    int k0 = domain->FirstRealK()+1;
    int k1 = domain->LastRealK()+1;

    // add global boundary cells
    if (i0 == 1) i0-- ;
    if (i1 == n) i1++;
    if (j0 == 1) j0-- ;
    if (j1 == m) j1++;
    if (k0 == 1) k0-- ;
    if (k1 == l) k1++;

    int I0 = 0; int I1 = n+1;
    int J0 = 0; int J1 = m+1;
    int K0 = 0; int K1 = l+1;

    DEBUG("create landmap without overlap...");
    Teuchos::RCP<Epetra_Map> landmap_loc0 = Utils::CreateMap(i0,i1,j0,j1,k0,k1,
                                                             I0,I1,J0,J1,K0,K1,*Comm);

    // create an overlapping distributed map
    i0 = domain->FirstI()+1; // 'grid-style' indexing is 1-based
    i1 = domain->LastI()+1;
    j0 = domain->FirstJ()+1;
    j1 = domain->LastJ()+1;
    k0 = domain->FirstK()+1;
    k1 = domain->LastK()+1;

    //add the boundary cells i=0,n+1 etc (this is independent of overlap)
    i0--; i1++; j0--; j1++; k0--; k1++;

    DEBUG("create landmap with overlap...");
    Teuchos::RCP<Epetra_Map> landmap_loc = Utils::CreateMap(i0,i1,j0,j1,k0,k1,
                                                            I0,I1,J0,J1,K0,K1,*Comm);

    DEBUG("Create local vectors...");

    // distributed non-overlapping version of landm
    Teuchos::RCP<Epetra_IntVector> landm_loc0 =
        Teuchos::rcp(new Epetra_IntVector(*landmap_loc0));

    // distributed overlapping version of landm
    Teuchos::RCP<Epetra_IntVector> landm_loc =
        Teuchos::rcp(new Epetra_IntVector(*landmap_loc));

    DEBUG("Create importers...");

    // scatter to non-overlapping vector
    Teuchos::RCP<Epetra_Import> scatter, exchange;
    const Epetra_BlockMap& landmap_glb = landm_glb->Map();
    DEBUG("Create Gather-Import");
    scatter = Teuchos::rcp(new Epetra_Import(landmap_glb,*landmap_loc0));
    // exchange overlap
    DEBUG("Create Overlap-Import");
    exchange = Teuchos::rcp(new Epetra_Import(*landmap_loc,*landmap_loc0));


    // this is a 'scatter' operation to an overlapping distribution
    DEBUG("Distribute landmask...");
    // this helps to identify errors
    landm_loc0->PutValue(-999);
    landm_loc->PutValue(42);

    // scatter
    CHECK_ZERO(landm_loc0->Export(*landm_glb, *scatter,Insert));

    // get boundaries correct
    CHECK_ZERO(landm_loc->Import(*landm_loc0, *exchange,Insert));

    return landm_loc;
}

//=============================================================================
void THCM::setIntCondCorrection(Teuchos::RCP<Epetra_Vector> vec)
{
    if (sres != 0)
    {
        WARNING("This should not be called when SRES!=0",
                __FILE__, __LINE__);
        return;
    }
    else
    {
        // compute salinity integral, put it in correction
        CHECK_ZERO(intcond_coeff->Dot(*vec, &intCorrection_));

        if (std::abs(intCorrection_) > 1e-8)
        {
            INFO("THCM integral correction: " << intCorrection_);
        }
    }
}

//=============================================================================
// Adjusting the integral condition using setIntCondCorrection above
// is preferred. Under non-restoring conditions: add a constant
// correction to the salinity values in order to satisfy the integral
// condition.
void THCM::adjustForIntCond(Teuchos::RCP<Epetra_Vector> vec)
{
    if (sres != 0)
    {
        WARNING("This should not be called when SRES!=0",
                __FILE__, __LINE__);
        return;
    }
    else
    {
        // compute salinity integral
        double integral;
        CHECK_ZERO(intcond_coeff->Dot(*vec, &integral));

        if (std::abs(integral) > 1e-8)
        {
            INFO("Adjusting for nonzero salinity integral: " << integral);

#ifdef DEBUGGING_NEW
            Utils::save(vec, "vec_to_adjust");
#endif

        }
        else
        {
            return;
        }

        // add correction to salinity values
        double correction = integral / totalVolume_;
        int row, lid;
        for (int k = 0; k != l; ++k)
            for (int j = 0; j != m; ++j)
                for (int i = 0; i != n; ++i)
                {
                    row = FIND_ROW2(_NUN_, n, m, l, i, j, k, SS);
                    lid = vec->Map().LID(row);
                    if (lid >= 0)
                        (*vec)[lid] -= correction;
                }
#ifdef DEBUGGING_NEW
        CHECK_ZERO(intcond_coeff->Dot(*vec, &integral));
        assert(std::abs(integral) < 1e-8);
        INFO("   integral     = " << integral);
        INFO("         V      = " << totalVolume_);
        INFO("   S correction = " << correction);
#endif
    }
}


//=============================================================================
//! Let THCM perform integral checks
void THCM::integralChecks(Teuchos::RCP<Epetra_Vector> state,
                          double &salt_advection,
                          double &salt_diffusion)
{
    if (!(state->Map().SameAs(*StandardMap)))
    {
        ERROR("Map of input vector not same as standard map ",__FILE__,__LINE__);
    }

    // Create vectors for integral coefficients
    Teuchos::RCP<Epetra_Vector> globalCoeff =
        Teuchos::rcp(new Epetra_Vector(*StandardVolumeMap));
    Teuchos::RCP<Epetra_Vector> localCoeff =
        Teuchos::rcp(new Epetra_Vector(*AssemblyVolumeMap));

    // Create pointer to view of local coefficients
    double *localCoeffView;
    localCoeff->ExtractView(&localCoeffView);

    // Create local state
    Teuchos::RCP<Epetra_Vector> localState =
        Teuchos::rcp(new Epetra_Vector(*AssemblyMap));

    // Import into local state
    domain->Solve2Assembly(*state, *localState);

    // Create pointer to view of local state entries
    double *localStateView;
    localState->ExtractView(&localStateView);

    // --------------------------------------------
    // Compute salt advection volume integral
    F90NAME( m_integrals, salt_advection )( localStateView, localCoeffView );

    // Export local coefficients into global entries
    CHECK_ZERO(globalCoeff->Export(*localCoeff, *as2std_vol, Zero));

    // Compute integral on global non-overlapping domain
    double localInt = 0.0;
    for (int i = 0; i != globalCoeff->Map().NumMyElements(); ++i)
        localInt += (*globalCoeff)[i];

    // Sum over subdomains, obtain resulting integral
    Comm->SumAll(&localInt, &salt_advection, 1);

    std::cout << "Salt advection integral, PID = " << Comm->MyPID() << " lSum = " << localInt
              << " gSum = " << salt_advection << std::endl;

    // Reset local coefficients and integral
    localCoeff->PutScalar(0.0);
    localInt = 0.0;

    // --------------------------------------------
    // Compute salt diffusion volume integral
    F90NAME( m_integrals, salt_diffusion )( localStateView, localCoeffView );

    // Export local coefficients into global non overlapping entries
    CHECK_ZERO(globalCoeff->Export(*localCoeff, *as2std_vol, Zero));

    // std::ofstream file;
    // std::stringstream ss;
    // ss << "globalCoeff" << Comm->MyPID();
    // file.open(ss.str());
    // globalCoeff->Print(file);
    // file.close();

    // Compute integral on subdomains
    for (int i = 0; i != globalCoeff->Map().NumMyElements(); ++i)
        localInt += (*globalCoeff)[i];

    // Sum over subdomains
    Comm->SumAll(&localInt, &salt_diffusion, 1);

    std::cout << "Salt diffusion integral, PID = " << Comm->MyPID() << " lSum = " << localInt
              << " gSum = " << salt_diffusion << std::endl;
}

//=============================================================================
// implement integral condition for S in Jacobian and B-matrix
void THCM::intcond_S(Epetra_CrsMatrix& A, Epetra_Vector& B)
{
    int N=domain->GlobalN();
    int M=domain->GlobalM();
    int L=domain->GlobalL();

    int root = Comm->NumProc()-1;

    Teuchos::RCP<Epetra_MultiVector> intcond_glob =
        Utils::Gather(*intcond_coeff, root);

    if (A.MyGRID(rowintcon_))
    {
        if (Comm->MyPID()!=root)
        {
            ERROR("S-integral condition should be on last processor!",__FILE__,__LINE__);
        }
        int lid = B.Map().LID(rowintcon_);
        B[lid]  = 0.0;   // no more time-dependence for this S-point
        int len = N*M*L;

        double *values = new double[len];
        int *indices   = new int[len];

        int pos=0;
        for (int i=0;i<N;i++)
            for (int j=0;j<M;j++)
                for (int k=0;k<L;k++)
                {
                    int gid = FIND_ROW2(_NUN_,N,M,L,i,j,k,SS);
                    indices[pos] = gid;

                    values[pos] = intSign_ * (*intcond_glob)[0][gid];
                    pos++;
                }

        /*
          len=1;
          indices[0]=rowintcon_;
          values[0]=1.0;
        */
        int ierr;
        if (A.Filled())
        {
            ierr = A.ReplaceGlobalValues(rowintcon_,len,values,indices);
        }
        else
        {
            ierr = A.InsertGlobalValues(rowintcon_,len,values,indices);
        }
        if (ierr != 0)
        {
            std::stringstream ss;
            ss << "graph_pid" << Comm->MyPID();
            std::ofstream file(ss.str());
            file << A.Graph();

            std::cout << "Insertion ERROR! " << ierr << ", filled = "
                      << A.Filled() << std::endl;

            std::cout << "\n ERROR " << ierr;
            std::cout << ((ierr == 2) ? ": value excluded" : "") << std::endl;
            std::cout << "\n myPID " << Comm->MyPID();

            std::cout << " while inserting/replacing values in local Jacobian" << std::endl;
            std::cout << "  GRID: " << rowintcon_ << std::endl;
            ERROR("Error during insertion/replacing of values in local Jacobian",
                  __FILE__, __LINE__);
        }

        delete []  values;
        delete []  indices;
    }
    else if (Comm->MyPID()==root)
    {
        ERROR("S-integral condition should be on last processor!",__FILE__,__LINE__);
    }
}

//=============================================================================
void THCM::fixPressurePoints(Epetra_CrsMatrix& A, Epetra_Vector& B)
{
    for (int i=1;i<=2;i++) {
        int row = (i==1)? rowPfix1: rowPfix2;
        if (A.MyGRID(row))
        {
            int lidB = B.Map().LID(row);
            int lidA = A.RowMap().LID(row);
            B[lidB] = 0.0; // no more time-dependence for this P-point

            int numEntries = A.NumMyEntries(lidA);
            double *vals   = new double[numEntries];
            int *inds      = new int[numEntries];

            // Extract current row and zero out except diagonal
            CHECK_NONNEG(A.ExtractGlobalRowCopy(row, numEntries, numEntries, vals, inds));
            for (int i = 0; i != numEntries; ++i)
            {
                if (inds[i] == row)
                    vals[i] = 1.0;
                else
                    vals[i] = 0.0;
            }

            if (A.Filled())
            {
                CHECK_NONNEG(A.ReplaceGlobalValues(row,numEntries,vals,inds));
            }
            else
            {
                CHECK_NONNEG(A.InsertGlobalValues(row,numEntries,vals,inds));
            }

            delete [] vals;
            delete [] inds;
        }
    }//for two pressure dirichlet values
}

//=============================================================================
Teuchos::RCP<Epetra_CrsGraph> THCM::CreateMaximalGraph(bool useSRES)
{
    DEBUG("Constructing maximal matrix graph...");
    int n=domain->LocalN();
    int m=domain->LocalM();
    int l=domain->LocalL();
    int ndim = StandardMap->NumMyElements();
    int *numEntriesPerRow = new int[ndim];
    //int *landm = new int[n*m*l];
    //F90NAME(m_thcm_utils,get_landm)(landm);
    //const int LAND=1;
    for (int k=1;k<=l;k++)
        for (int j=1;j<=m;j++)
            for (int i=1;i<=n;i++)
            {
                int lidU = FIND_ROW2(_NUN_,n,m,l,i-1,j-1,k-1,UU);
                int gidU = AssemblyMap->GID(lidU);
                if (StandardMap->MyGID(gidU)) // otherwise: ghost cell, not in Jacobian
                {
                    int lid0 = StandardMap->LID(gidU)-1;
                    numEntriesPerRow[lid0+UU] = 24;
                    numEntriesPerRow[lid0+VV] = 22;
                    numEntriesPerRow[lid0+WW] = 7;
                    numEntriesPerRow[lid0+PP] = 11;
                    numEntriesPerRow[lid0+TT] = 20;
                    numEntriesPerRow[lid0+SS] = 20;
                }
            }

    Teuchos::RCP<Epetra_CrsGraph> graph
        = Teuchos::rcp(new Epetra_CrsGraph(Copy,*StandardMap,numEntriesPerRow,false));

    DEBVAR(rowintcon_);
    DEBVAR(sres);

    int indices[24];
    int N = domain->GlobalN();
    int M = domain->GlobalM();
    int L = domain->GlobalL();

    int I0 = domain->FirstRealI();
    int J0 = domain->FirstRealJ();
    int K0 = domain->FirstRealK();
    int I1 = domain->LastRealI();
    int J1 = domain->LastRealJ();
    int K1 = domain->LastRealK();
    int pos; // counts nonzero's per row and keeps track of position
    for (int k=K0; k<=K1; k++)
        for (int j=J0; j<=J1; j++)
            for (int i=I0; i<=I1; i++)
            {
                int gidU = FIND_ROW2(_NUN_,N,M,L,i,j,k,UU);
                int gid0 = gidU-1;

                // U-equation
                pos=0;

                // u-u: 7-point stencil
                insert_graph_entry(indices,pos,i,j,k,UU,N,M,L);
                insert_graph_entry(indices,pos,i-1,j,k,UU,N,M,L);
                insert_graph_entry(indices,pos,i+1,j,k,UU,N,M,L);
                insert_graph_entry(indices,pos,i,j-1,k,UU,N,M,L);
                insert_graph_entry(indices,pos,i,j+1,k,UU,N,M,L);
                insert_graph_entry(indices,pos,i,j,k-1,UU,N,M,L);
                insert_graph_entry(indices,pos,i,j,k+1,UU,N,M,L);

                // u-v: 5-point stencil TODO: why is it 5 in U and 3 in V-eqn?
                insert_graph_entry(indices,pos,i,j,k,VV,N,M,L);
                insert_graph_entry(indices,pos,i-1,j,k,VV,N,M,L);
                insert_graph_entry(indices,pos,i+1,j,k,VV,N,M,L);
                insert_graph_entry(indices,pos,i,j-1,k,VV,N,M,L);
                insert_graph_entry(indices,pos,i,j+1,k,VV,N,M,L);

                // u-w: cell-averages at level k and k-1
                insert_graph_entry(indices,pos,i,j,k,WW,N,M,L);
                insert_graph_entry(indices,pos,i+1,j,k,WW,N,M,L);
                insert_graph_entry(indices,pos,i+1,j+1,k,WW,N,M,L);
                insert_graph_entry(indices,pos,i,j+1,k,WW,N,M,L);

                insert_graph_entry(indices,pos,i,j,k-1,WW,N,M,L);
                insert_graph_entry(indices,pos,i+1,j,k-1,WW,N,M,L);
                insert_graph_entry(indices,pos,i+1,j+1,k-1,WW,N,M,L);
                insert_graph_entry(indices,pos,i,j+1,k-1,WW,N,M,L);

                // u-p: gradient
                insert_graph_entry(indices,pos,i,j,k,PP,N,M,L);
                insert_graph_entry(indices,pos,i+1,j,k,PP,N,M,L);
                insert_graph_entry(indices,pos,i,j+1,k,PP,N,M,L);
                insert_graph_entry(indices,pos,i+1,j+1,k,PP,N,M,L);

//#ifdef DEBUGGING
#if 0
#define DEBUG_GRAPH_ROW(var)                                            \
                std::cout << "graph row "<<i<<" "<<j<<" "<<k<<" "<<var;     \
                std::cout << " (gid "<<(gid0+var)<<"):"<<std::endl;         \
                std::cout << "predicted length: "<<numEntriesPerRow[StandardMap->LID(gid0+var)]; \
                std::cout <<", actual length: "<<pos<<std::endl;        \
                for (int pp=0;pp<pos;pp++) std::cout << (indices)[pp]<<" ";     \
                std::cout << std::endl;
#else
#define DEBUG_GRAPH_ROW(var)
#endif
//"
                DEBUG_GRAPH_ROW(UU)
                    CHECK_ZERO(graph->InsertGlobalIndices(gid0+UU,pos,indices));

                // v-equation
                pos=0;

                // v-v: 7-point stencil
                insert_graph_entry(indices,pos,i,j,k,VV,N,M,L);
                insert_graph_entry(indices,pos,i-1,j,k,VV,N,M,L);
                insert_graph_entry(indices,pos,i+1,j,k,VV,N,M,L);
                insert_graph_entry(indices,pos,i,j-1,k,VV,N,M,L);
                insert_graph_entry(indices,pos,i,j+1,k,VV,N,M,L);
                insert_graph_entry(indices,pos,i,j,k-1,VV,N,M,L);
                insert_graph_entry(indices,pos,i,j,k+1,VV,N,M,L);

                // v-u: 3-point stencil (why not 5, as in u-v?)
                insert_graph_entry(indices,pos,i,j,k,UU,N,M,L);
                insert_graph_entry(indices,pos,i-1,j,k,UU,N,M,L);
                insert_graph_entry(indices,pos,i+1,j,k,UU,N,M,L);

                // v-w: cell-averages at level k and k-1
                insert_graph_entry(indices,pos,i,j,k,WW,N,M,L);
                insert_graph_entry(indices,pos,i+1,j,k,WW,N,M,L);
                insert_graph_entry(indices,pos,i+1,j+1,k,WW,N,M,L);
                insert_graph_entry(indices,pos,i,j+1,k,WW,N,M,L);

                insert_graph_entry(indices,pos,i,j,k-1,WW,N,M,L);
                insert_graph_entry(indices,pos,i+1,j,k-1,WW,N,M,L);
                insert_graph_entry(indices,pos,i+1,j+1,k-1,WW,N,M,L);
                insert_graph_entry(indices,pos,i,j+1,k-1,WW,N,M,L);

                // v-p: gradient
                insert_graph_entry(indices,pos,i,j,k,PP,N,M,L);
                insert_graph_entry(indices,pos,i+1,j,k,PP,N,M,L);
                insert_graph_entry(indices,pos,i,j+1,k,PP,N,M,L);
                insert_graph_entry(indices,pos,i+1,j+1,k,PP,N,M,L);

                DEBUG_GRAPH_ROW(VV)
                    CHECK_ZERO(graph->InsertGlobalIndices(gid0+VV,pos,indices));

                // w-equation
                pos=0;

                insert_graph_entry(indices,pos,i,j,k,WW,N,M,L);
                insert_graph_entry(indices,pos,i,j,k,PP,N,M,L);
                insert_graph_entry(indices,pos,i,j,k+1,PP,N,M,L);
                insert_graph_entry(indices,pos,i,j,k,TT,N,M,L);
                insert_graph_entry(indices,pos,i,j,k+1,TT,N,M,L);
                insert_graph_entry(indices,pos,i,j,k,SS,N,M,L);
                insert_graph_entry(indices,pos,i,j,k+1,SS,N,M,L);

                DEBUG_GRAPH_ROW(WW)
                    CHECK_ZERO(graph->InsertGlobalIndices(gid0+WW,pos,indices));

                // continuity-equation
                pos=0;

                insert_graph_entry(indices,pos,i,j,k,PP,N,M,L);

                insert_graph_entry(indices,pos,i,j,k,UU,N,M,L);
                insert_graph_entry(indices,pos,i-1,j,k,UU,N,M,L);
                insert_graph_entry(indices,pos,i,j-1,k,UU,N,M,L);
                insert_graph_entry(indices,pos,i-1,j-1,k,UU,N,M,L);

                insert_graph_entry(indices,pos,i,j,k,VV,N,M,L);
                insert_graph_entry(indices,pos,i-1,j,k,VV,N,M,L);
                insert_graph_entry(indices,pos,i,j-1,k,VV,N,M,L);
                insert_graph_entry(indices,pos,i-1,j-1,k,VV,N,M,L);

                insert_graph_entry(indices,pos,i,j,k,WW,N,M,L);
                insert_graph_entry(indices,pos,i,j,k-1,WW,N,M,L);

                DEBUG_GRAPH_ROW(PP)
                    CHECK_ZERO(graph->InsertGlobalIndices(gid0+PP,pos,indices));

                // T-equation
                pos=0;

                // T-T: 7-point stencil
                insert_graph_entry(indices,pos,i,j,k,TT,N,M,L);
                insert_graph_entry(indices,pos,i-1,j,k,TT,N,M,L);
                insert_graph_entry(indices,pos,i+1,j,k,TT,N,M,L);
                insert_graph_entry(indices,pos,i,j-1,k,TT,N,M,L);
                insert_graph_entry(indices,pos,i,j+1,k,TT,N,M,L);
                insert_graph_entry(indices,pos,i,j,k-1,TT,N,M,L);
                insert_graph_entry(indices,pos,i,j,k+1,TT,N,M,L);

                // T-U/V/W:
                insert_graph_entry(indices,pos,i,j,k,UU,N,M,L);
                insert_graph_entry(indices,pos,i-1,j,k,UU,N,M,L);
                insert_graph_entry(indices,pos,i-1,j-1,k,UU,N,M,L);
                insert_graph_entry(indices,pos,i,j-1,k,UU,N,M,L);

                insert_graph_entry(indices,pos,i,j,k,VV,N,M,L);
                insert_graph_entry(indices,pos,i-1,j,k,VV,N,M,L);
                insert_graph_entry(indices,pos,i-1,j-1,k,VV,N,M,L);
                insert_graph_entry(indices,pos,i,j-1,k,VV,N,M,L);

                insert_graph_entry(indices,pos,i,j,k,WW,N,M,L);
                insert_graph_entry(indices,pos,i,j,k-1,WW,N,M,L);

                // T-S: these terms may enter due to convective adjustment
                insert_graph_entry(indices,pos,i,j,k,SS,N,M,L);
                insert_graph_entry(indices,pos,i,j,k-1,SS,N,M,L);
                insert_graph_entry(indices,pos,i,j,k+1,SS,N,M,L);

                DEBUG_GRAPH_ROW(TT)
                    CHECK_ZERO(graph->InsertGlobalIndices(gid0+TT,pos,indices));

                // S-equation
                pos=0;

                // S-S: 7-point stencil
                insert_graph_entry(indices,pos,i,j,k,SS,N,M,L);
                insert_graph_entry(indices,pos,i-1,j,k,SS,N,M,L);
                insert_graph_entry(indices,pos,i+1,j,k,SS,N,M,L);
                insert_graph_entry(indices,pos,i,j-1,k,SS,N,M,L);
                insert_graph_entry(indices,pos,i,j+1,k,SS,N,M,L);
                insert_graph_entry(indices,pos,i,j,k-1,SS,N,M,L);
                insert_graph_entry(indices,pos,i,j,k+1,SS,N,M,L);

                // S-U/V/W:
                insert_graph_entry(indices,pos,i,j,k,UU,N,M,L);
                insert_graph_entry(indices,pos,i-1,j,k,UU,N,M,L);
                insert_graph_entry(indices,pos,i-1,j-1,k,UU,N,M,L);
                insert_graph_entry(indices,pos,i,j-1,k,UU,N,M,L);

                insert_graph_entry(indices,pos,i,j,k,VV,N,M,L);
                insert_graph_entry(indices,pos,i-1,j,k,VV,N,M,L);
                insert_graph_entry(indices,pos,i-1,j-1,k,VV,N,M,L);
                insert_graph_entry(indices,pos,i,j-1,k,VV,N,M,L);

                insert_graph_entry(indices,pos,i,j,k,WW,N,M,L);
                insert_graph_entry(indices,pos,i,j,k-1,WW,N,M,L);

                // S-T: these terms may enter due to convective adjustment
                insert_graph_entry(indices,pos,i,j,k,TT,N,M,L);
                insert_graph_entry(indices,pos,i,j,k-1,TT,N,M,L);
                insert_graph_entry(indices,pos,i,j,k+1,TT,N,M,L);
#ifndef NO_INTCOND
                if ( (sres == 0) &&
                     ( (gid0+SS) == rowintcon_ ) &&
                     useSRES)
                    continue;
#endif
                DEBUG_GRAPH_ROW(SS)
                    CHECK_ZERO(graph->InsertGlobalIndices(gid0+SS,pos,indices));
            }

#ifndef NO_INTCOND
    if ((sres == 0) && useSRES)
    {
        int grid = rowintcon_;
        if (StandardMap->MyGID(grid))
        {
            int len = N*M*L;
            int *inds = new int[len];
            pos=0;
            for (int i=0;i<N;i++)
                for (int j=0;j<M;j++)
                    for (int k=0;k<L;k++)
                    {
                        int gcid = FIND_ROW2(_NUN_,N,M,L,i,j,k,SS);
                        inds[pos] = gcid;
                        pos++;
                    }
            CHECK_NONNEG(graph->InsertGlobalIndices(grid,len,inds));
            delete [] inds;
        }
    }
#endif
    CHECK_ZERO(graph->FillComplete());

    //delete [] landm;
    delete [] numEntriesPerRow;

    return graph;
}

//=============================================================================
void THCM::insert_graph_entry(int* indices, int& pos,
                              int i, int j, int k, int xx,
                              int N, int M, int L) const
{
    int ii=i; // if x-boundary is periodic i may be out of bounds.
    // ii will be adjusted in that case:
    if (domain->IsPeriodic())
    {
        ii = MOD((double)i,(double)N);
    }
    if ((ii>=0) && (j>=0) && (k>=0) &&
        (ii< N) && (j< M) && (k< L) )
    {
        indices[pos++] = FIND_ROW2(_NUN_,N,M,L,ii,j,k,xx);
    }
}

//=============================================================================
double THCM::getSCorr()
{
    getFluxes();
    return scorr_;
}

//=============================================================================
Teuchos::RCP<Epetra_Vector> THCM::getIntCondCoeff()
{
    intcond_coeff->PutScalar(0.0);
    Teuchos::RCP<Epetra_Vector> intcond_tmp =
        Teuchos::rcp(new Epetra_Vector(*AssemblyMap));

    int nml = (domain->LocalN())*(domain->LocalM())*(domain->LocalL());

    double *values = new double[nml];
    int *indices   = new int[nml];
    int len;
    F90NAME(m_thcm_utils, intcond_scaling)(values, indices, &len);

    for (int i=0;i<len;i++)
    {
        (*intcond_tmp)[indices[i]-1] = values[i];
    }

    delete [] values;
    delete [] indices;

    domain->Assembly2Solve(*intcond_tmp,*intcond_coeff);

    intcond_coeff->Norm1(&totalVolume_);

    INFO("  total volume: " << totalVolume_);

    return intcond_coeff;
}

//=============================================================================
// set vmix_fix
void THCM::fixMixing(int value)
{
    if (vmix_GLB == 2)
    {
        INFO(" ** fixing vmix_fix: " << value << " **");
        F90NAME(m_mix, set_vmix_fix)(&value);
    }
}

//=============================================================================
void THCM::SetupMonthlyForcing()
{
    DEBUG("Initialize monthly Levitus...");

    // maps for 2D fields (surface forcing)
    Teuchos::RCP<Epetra_Map> lev_map_dist = domain->CreateStandardMap(1,true);
    Teuchos::RCP<Epetra_Map> lev_map_root = Utils::Gather(*lev_map_dist,0);

    // maps for 3D fields (internal forcing)
    Teuchos::RCP<Epetra_Map> intlev_map_dist = domain->CreateStandardMap(1,false);
    Teuchos::RCP<Epetra_Map> intlev_map_root = Utils::Gather(*intlev_map_dist,0);

    // create sequential and parallel vectors to hold the data
    Teuchos::RCP<Epetra_MultiVector> temp_glob =
        Teuchos::rcp(new Epetra_Vector(*intlev_map_root));
    Teuchos::RCP<Epetra_MultiVector> salt_glob =
        Teuchos::rcp(new Epetra_Vector(*intlev_map_root));

    Teuchos::RCP<Epetra_MultiVector> tatm_glob =
        Teuchos::rcp(new Epetra_Vector(*lev_map_root));
    Teuchos::RCP<Epetra_MultiVector> emip_glob =
        Teuchos::rcp(new Epetra_Vector(*lev_map_root));

    Teuchos::RCP<Epetra_MultiVector> taux_glob =
        Teuchos::rcp(new Epetra_Vector(*lev_map_root));
    Teuchos::RCP<Epetra_MultiVector> tauy_glob =
        Teuchos::rcp(new Epetra_Vector(*lev_map_root));

    // get raw pointers to the data:
    double *tatm_g, *emip_g, *taux_g, *tauy_g, *temp_g, *salt_g;
    CHECK_ZERO((*tatm_glob)(0)->ExtractView(&tatm_g));
    CHECK_ZERO((*emip_glob)(0)->ExtractView(&emip_g));
    CHECK_ZERO((*temp_glob)(0)->ExtractView(&temp_g));
    CHECK_ZERO((*salt_glob)(0)->ExtractView(&salt_g));
    CHECK_ZERO((*taux_glob)(0)->ExtractView(&taux_g));
    CHECK_ZERO((*tauy_glob)(0)->ExtractView(&tauy_g));

    // now create distributed maps
    Teuchos::RCP<Epetra_Map> lev_map_loc    = domain->CreateAssemblyMap(1,true);
    Teuchos::RCP<Epetra_Map> intlev_map_loc = domain->CreateAssemblyMap(1,false);

    // and distributed vectors
    Teuchos::RCP<Epetra_Vector> tatm_loc = Teuchos::rcp(new Epetra_Vector(*lev_map_loc));
    Teuchos::RCP<Epetra_Vector> emip_loc = Teuchos::rcp(new Epetra_Vector(*lev_map_loc));
    Teuchos::RCP<Epetra_Vector> temp_loc = Teuchos::rcp(new Epetra_Vector(*intlev_map_loc));
    Teuchos::RCP<Epetra_Vector> salt_loc = Teuchos::rcp(new Epetra_Vector(*intlev_map_loc));
    Teuchos::RCP<Epetra_Vector> taux_loc = Teuchos::rcp(new Epetra_Vector(*lev_map_loc));
    Teuchos::RCP<Epetra_Vector> tauy_loc = Teuchos::rcp(new Epetra_Vector(*lev_map_loc));

    // extract pointers to the distributed data
    double* ctatm,*cemip,*ctaux,*ctauy,*ctemp,*csalt;
    CHECK_ZERO(tatm_loc->ExtractView(&ctatm));
    CHECK_ZERO(emip_loc->ExtractView(&cemip));
    CHECK_ZERO(temp_loc->ExtractView(&ctemp));
    CHECK_ZERO(salt_loc->ExtractView(&csalt));
    CHECK_ZERO(taux_loc->ExtractView(&ctaux));
    CHECK_ZERO(tauy_loc->ExtractView(&ctauy));

    // to import overlap
    Teuchos::RCP<Epetra_Import> loc2dist =
        Teuchos::rcp(new Epetra_Import(*lev_map_loc,*lev_map_dist));
    Teuchos::RCP<Epetra_Import> int_loc2dist =
        Teuchos::rcp(new Epetra_Import(*intlev_map_loc,*intlev_map_dist));

    for (int month=1;month<=12;month++)
    {
        if (Comm->MyPID()==0)
        {
            F90NAME(m_global,get_monthly_forcing)(tatm_g,emip_g,taux_g,tauy_g,&month);
            if (internal_forcing)
            {
                F90NAME(m_global,get_monthly_internal_forcing)(temp_g,salt_g,&month);
            }
        }

        // distribute levitus and wind fields
        Teuchos::RCP<Epetra_MultiVector> tatm_dist = Utils::Scatter(*tatm_glob,*lev_map_dist);
        Teuchos::RCP<Epetra_MultiVector> emip_dist = Utils::Scatter(*emip_glob,*lev_map_dist);
        Teuchos::RCP<Epetra_MultiVector> temp_dist = Utils::Scatter(*temp_glob,*intlev_map_dist);
        Teuchos::RCP<Epetra_MultiVector> salt_dist = Utils::Scatter(*salt_glob,*intlev_map_dist);
        Teuchos::RCP<Epetra_MultiVector> taux_dist = Utils::Scatter(*taux_glob,*lev_map_dist);
        Teuchos::RCP<Epetra_MultiVector> tauy_dist = Utils::Scatter(*tauy_glob,*lev_map_dist);

        CHECK_ZERO(tatm_loc->Import(*tatm_dist,*loc2dist,Insert));
        CHECK_ZERO(emip_loc->Import(*emip_dist,*loc2dist,Insert));
        CHECK_ZERO(temp_loc->Import(*temp_dist,*int_loc2dist,Insert));
        CHECK_ZERO(salt_loc->Import(*salt_dist,*int_loc2dist,Insert));
        CHECK_ZERO(taux_loc->Import(*taux_dist,*loc2dist,Insert));
        CHECK_ZERO(tauy_loc->Import(*tauy_dist,*loc2dist,Insert));

        double tatmmax, emipmax;
        double tatmmin, emipmin;
        CHECK_ZERO(tatm_dist->MaxValue(&tatmmax));
        CHECK_ZERO(emip_dist->MaxValue(&emipmax));
        CHECK_ZERO(tatm_dist->MinValue(&tatmmin));
        CHECK_ZERO(emip_dist->MinValue(&emipmin));

        INFO("Month: " << month);
        INFO("Temperature-forcing range: [" << tatmmin << ".." << tatmmax << "]");
        INFO("Salinity-forcing range: [" << emipmin << ".." << emipmax << "]");

        F90NAME(m_monthly,set_forcing)(ctatm,cemip,ctaux,ctauy,&month);
        if (internal_forcing)
        {
            F90NAME(m_monthly,set_internal_forcing)(ctemp,csalt,&month);
        }
    }
}

//=============================================================================
extern "C" {

// this is a cheat for the fortran routine fsint from forcing.F90
    void thcm_forcing_integral_(double* qfun2, double* y, int* landm, double* fsint)
    {
        Teuchos::RCP<Epetra_Comm> comm = THCM::Instance().GetComm();
        Teuchos::RCP<TRIOS::Domain> domain = THCM::Instance().GetDomain();

        int n = domain->LocalN();
        int m = domain->LocalM();
        int l = domain->LocalL();

        double lsint = 0.0, lfsint=0.0, sint;

        int i0 = domain->FirstRealI()-domain->FirstI();
        int j0 = domain->FirstRealJ()-domain->FirstJ();

        int i1 = domain->LastRealI()-domain->FirstI();
        int j1 = domain->LastRealJ()-domain->FirstJ();

        for (int j=j0; j<=j1; j++)
        {
            for (int i=i0;i<=i1;i++)
            {
                //note: the fortran landm array is 0-based, so we add a 1 to i,j,k
                int pl = FIND_ROW2(1,n+2,m+2,l+2,i+1,j+1,l,1);
                int pq = FIND_ROW2(1,n,m,1,i,j,0,1);
                lfsint = qfun2[pq] * cos(y[j]) * (1 - landm[pl]) + lfsint;
                lsint  = cos(y[j]) * (1 - landm[pl]) + lsint;
            }
        }

        CHECK_ZERO( comm->SumAll(&lfsint,fsint,1) );
        CHECK_ZERO( comm->SumAll(&lsint,&sint,1) );

        *fsint = *fsint/sint;
    }

    //------------------------------------------------------------------
    // helper function to let the fortran code participate in error handling
    void thcm_throw_error_(char *msg)
    {
        ERROR(msg, "the fortran code", "somewhere");
    }
}

Teuchos::RCP<const Epetra_MultiVector> THCM::getNullSpace()
{
    if (nullSpace==Teuchos::null)
    {
        nullSpace = Teuchos::rcp(new Epetra_MultiVector
                                 (*StandardMap,2,true) );

        // the svp's are fairly easy to construct, they are
        // so-called 'checkerboard' modes' in the x-y planes.
        // we first construct them for the standard rectan-
        // gular subdomains and then export them to the load-
        // balanced 'solve' map TODO: typically the two are the
        // same (unless load balancing is active), so we currently
        // don't actually do the export. Load balancing is likely
        // to be discarded in the near future anyway.

        // loop over all non-ghost subdomain cells:
        int pos=PP-1;
        for (int k=domain->FirstRealK();k<=domain->LastRealK();k++)
            for (int j=domain->FirstRealJ();j<=domain->LastRealJ();j++)
                for (int i=domain->FirstRealI();i<=domain->LastRealI();i++)
                {
                    if ((i+j)%2)
                    {
                        (*(*nullSpace)(0))[pos] = 1;
                    }
                    else
                    {
                        (*(*nullSpace)(1))[pos] = 1;
                    }
                    pos+=_NUN_;
                }

        double nrm1,nrm2;
        CHECK_ZERO((*nullSpace)(0)->Norm2(&nrm1));
        CHECK_ZERO((*nullSpace)(1)->Norm2(&nrm2));
        CHECK_ZERO((*nullSpace)(0)->Scale(1.0/nrm1));
        CHECK_ZERO((*nullSpace)(1)->Scale(1.0/nrm2));
    }
    return nullSpace;
}

//=============================================================================
Teuchos::ParameterList
THCM::getDefaultInitParameters()
{
    Teuchos::ParameterList result = getDefaultParameters();

    result.get("Problem Description","Unnamed");

    result.get("Grid Stretching qz", 1.0);
    result.get("Topography", 1);
    result.get("Flat Bottom", false);

    result.get("Read Land Mask", false); //== false in experiment0
    result.get("Land Mask","no_mask_specified");

    result.get("Coriolis Force", 1);
    result.get("Forcing Type", 0);

    result.get("Read Salinity Perturbation Mask",false);
    result.get("Salinity Perturbation Mask", "no_mask_specified");

    result.get("Wind Forcing Data", "wind/trtau.dat");
    result.get("Temperature Forcing Data", "levitus/new/t00an1");
    result.get("Salinity Forcing Data", "levitus/new/s00an1");

    result.get("Time Dependent Forcing", false);

    result.get("Integral row coordinate i", -1);
    result.get("Integral row coordinate j", -1);

    return result;
}

Teuchos::ParameterList
THCM::getDefaultParameters()
{
    Teuchos::ParameterList result;
    result.get("Global Grid-Size n", 16);
    result.get("Global Grid-Size m", 16);
    result.get("Global Grid-Size l", 16);

    // default: north atlantic
    result.get("Global Bound xmin", 286.0);
    result.get("Global Bound xmax", 350.0);
    result.get("Global Bound ymin", 10.0);
    result.get("Global Bound ymax", 74.0);
    result.get("Periodic", false);

    result.get("Depth hdim", 4000.0);
    result.get("Compute salinity integral", true);

    result.get("Inhomogeneous Mixing",0);
    result.get("Mixing",1);
    result.get("Rho Mixing",true);
    result.get("Taper",1);
    result.get("Linear EOS: alpha T", 1.0e-4);
    result.get("Linear EOS: alpha S", 7.6e-4);
    result.get("Restoring Temperature Profile",1);
    result.get("Restoring Salinity Profile",1);
    result.get("Local SRES Only", false);
    result.get("Salinity Integral Sign", -1);
    result.get("Levitus T", 1);
    result.get("Levitus S", 1);
    result.get("Levitus Internal T/S",false);
    result.get("Coupled Temperature", 0);
    result.get("Coupled Salinity", 0);
    result.get("Coupled Sea Ice Mask", 1);
    result.get("Fix Pressure Points", false);
    result.get("Wind Forcing Type",2);
    result.get("Scaling","THCM");

    Teuchos::ParameterList& startParams = result.sublist("Starting Parameters");
    for (int i=0; i<= _NPAR_ + _NPAR_TRILI; i++)
    {
        std::string label = int2par(i);
        startParams.get(label, defaultParameter(label));
    }

    return result;
}

const Teuchos::ParameterList& THCM::getParameters()
{ return *paramList; }

void THCM::setPreParameters()
{
    n = paramList->get<int>("Global Grid-Size n");
    m = paramList->get<int>("Global Grid-Size m");
    l = paramList->get<int>("Global Grid-Size l");

    // default: north atlantic
    xmin = paramList->get<double>("Global Bound xmin") * PI_ / 180.0;
    xmax = paramList->get<double>("Global Bound xmax") * PI_ / 180.0;
    ymin = paramList->get<double>("Global Bound ymin") * PI_ / 180.0;
    ymax = paramList->get<double>("Global Bound ymax") * PI_ / 180.0;
    periodic           = paramList->get<bool>("Periodic");

    hdim               = paramList->get<double>("Depth hdim");
    comp_sal_int       = paramList->get<bool>("Compute salinity integral");
    ih                 = paramList->get<int>("Inhomogeneous Mixing");
    vmix_GLB           = paramList->get<int>("Mixing");
    rho_mixing         = paramList->get<bool>("Rho Mixing");
    tap                = paramList->get<int>("Taper");
    alphaT             = paramList->get<double>("Linear EOS: alpha T");
    alphaS             = paramList->get<double>("Linear EOS: alpha S");
    tres               = paramList->get<int>("Restoring Temperature Profile");
    sres               = paramList->get<int>("Restoring Salinity Profile");
    localSres_         = paramList->get<bool>("Local SRES Only");
    intSign_           = paramList->get<int>("Salinity Integral Sign");
    ite                = paramList->get<int>("Levitus T");
    its                = paramList->get<int>("Levitus S");
    internal_forcing   = paramList->get<bool>("Levitus Internal T/S");
    coupled_T          = paramList->get<int>("Coupled Temperature");
    coupled_S          = paramList->get<int>("Coupled Salinity");
    coupled_M          = paramList->get<int>("Coupled Sea Ice Mask");
    fixPressurePoints_ = paramList->get<bool>("Fix Pressure Points");
    iza                = paramList->get<int>("Wind Forcing Type");

    scaling_type       = paramList->get<std::string>("Scaling");
}

void THCM::setPostParameters()
{
    double value; //Only used to determine return type of getValue
    for (const auto& param : paramList->sublist("Starting Parameters")) {
        if (!std::isnan(param.second.getValue(&value))) {
            this->setParameter(param.first, param.second.getValue(&value));
        } else {
            std::string name = param.first;
            int p = par2int(name);
            FNAME(getparcs)(&p,&value);
            paramList->sublist("Starting Parameters").remove(name);
            paramList->sublist("Starting Parameters").get(name, value);
        }
    }
}

void THCM::setParameters(Teuchos::ParameterList& newParams)
{
    Teuchos::ParameterList tmpParams(*paramList);
    tmpParams.setParameters(newParams);
    tmpParams.validateParametersAndSetDefaults(getDefaultInitParameters());

    paramList->setParameters(tmpParams);

    setPreParameters();

    //------------------------------------------------------------------
    if ((coupled_S == 1) && (sres == 1))
    {
        WARNING("Incompatible parameters: coupled_S = " << coupled_S
                << " sres = "
                << sres << " setting sres = 0", __FILE__, __LINE__);
        sres = 0;
    }
    
    setPostParameters();

    newParams=*paramList;
}
